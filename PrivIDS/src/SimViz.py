#!/usr/bin/python#----------------------------------------------------------------------------#    # Author: Peter Nemeckay# Date:   Mar 1, 2012## SimViz visualizes the communication of the wireless sensor network. It can also# generate network topology, define breakpoints, send packet, log variables.## Based on previous version made by: Petr Stepanek, url #----------------------------------------------------------------------------# Copyright 2012, Peter Nemeckay ## This program is free software: you can redistribute it and/or modify# it under the terms of the GNU General Public License as published by# the Free Software Foundation, either version 3 of the License, or# (at your option) any later version.## This program is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the# GNU General Public License for more details.## You should have received a copy of the GNU General Public License# along with this program.  If not, see <http://www.gnu.org/licenses/>.#----------------------------------------------------------------------------import gobjectimport pygtkimport time pygtk.require("2.0")import gtkimport sysimport csvimport cairoimport pangocairoimport pangofrom math import pi, hypot, sqrt, fabsfrom random import randrange, Random, randomfrom collections import dequeimport sysimport ossys.path.append("/opt/tinyos-2.1.1/support/sdk/python/")# Init TOSSIM and prepare Tossim objectfrom TOSSIM import *from tinyos.tossim.TossimApp import *n = NescApp()t = Tossim(n.variables.variables())PATH = os.path.abspath(os.path.dirname(__file__)) + "/"              class Window:    def __init__(self):                                #        Inicialization of the main window        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)        self.window.set_title("SimViz")        self.window.set_position(gtk.WIN_POS_MOUSE)        self.window.set_size_request(12, 102)                self.window.set_default_size(810, 610) #top menu is 90px height                self.nodeSize = 10        self.numberOfNodes = 0        self.radius = 0        self.topologyGenMethod = 1        self.resizeRequest = False        self.screen = None        #        Placing all the widgets#       vBox        self.vBox = gtk.VBox(False, 5)#       hBox        self.hBox = gtk.HBox(False, 0)#       vBox1        self.vBox1 = gtk.VBox(False, 4)#       hBox1        self.hBox1 = gtk.HBox(False, 5)#        Canvas x lable        self.canvasXLabel = gtk.Label("Canvas x:")        self.hBox1.pack_start(self.canvasXLabel, False, True, 0)        self.canvasXLabel.show()#        Canvas x entry        self.canvasXEntry = gtk.Entry(0)        self.canvasXEntry.set_text("950")        self.canvasXEntry.set_width_chars(5)        self.hBox1.pack_start(self.canvasXEntry, False, True, 0)        self.canvasXEntry.show()#        Canvas y label        self.canvasYLabel = gtk.Label("y:")        self.hBox1.pack_start(self.canvasYLabel, False, True, 0)        self.canvasYLabel.show()#        Canvas y entry        self.canvasYEntry = gtk.Entry(0)        self.canvasYEntry.set_text("600")        self.canvasYEntry.set_width_chars(4)        self.hBox1.pack_start(self.canvasYEntry, False, True, 0)        self.canvasYEntry.show()#        Separator 1        self.separator1 = gtk.VSeparator()        self.hBox1.pack_start(self.separator1, False, True, 0)        self.separator1.show()#        Number label        self.numberLabel = gtk.Label("Nodes:")        self.hBox1.pack_start(self.numberLabel, False, True, 0)        self.numberLabel.show()#        Number entry        self.numberEntry = gtk.Entry(5)        self.numberEntry.set_text("20")        self.numberEntry.set_width_chars(5)        self.hBox1.pack_start(self.numberEntry, False, True, 0)        self.numberEntry.show()        #        Separator 2        self.separator2 = gtk.VSeparator()        self.hBox1.pack_start(self.separator2, False, True, 0)        self.separator2.show()        #        Radius entry        self.radiusLabel = gtk.Label("Radius:")        self.hBox1.pack_start(self.radiusLabel, False, True, 0)        # self.radiusLabel.show()        self.radiusEntry = gtk.Entry(4)        self.radiusEntry.set_text("200")        self.radiusEntry.set_width_chars(4)        self.hBox1.pack_start(self.radiusEntry, False, True, 0)                self.visualisationOff = gtk.CheckButton("Visualisation Off")        self.visualisationOff.set_active(False)        self.hBox1.pack_start(self.visualisationOff, True, True, 0)        self.visualisationOff.show()        # self.radiusEntry.show()        #        Separator 3        self.separator3 = gtk.VSeparator()        self.hBox1.pack_start(self.separator3, False, True, 0)        # self.separator3.show()        #        NeighboursLimit label        self.neighboursLimitLabel = gtk.Label("Max neighbours:")        self.hBox1.pack_start(self.neighboursLimitLabel, False, True, 0)        #        NeighboursLimit entry        self.neighboursLimitEntry = gtk.Entry(0)        self.neighboursLimitEntry.set_text("8")        self.neighboursLimitEntry.set_width_chars(2)        self.hBox1.pack_start(self.neighboursLimitEntry, False, True, 0)        #        Grid label        self.gridLabel = gtk.Label("Grid proportions:")        self.hBox1.pack_start(self.gridLabel, False, True, 0)        self.vBox1.pack_start(self.hBox1, False, True, 0)        self.hBox1.show()                        #        Grid x label        self.gridXLabel = gtk.Label("x:")        self.hBox1.pack_start(self.gridXLabel, False, True, 0)        #        Grid x entry        self.gridXEntry = gtk.Entry(0)        self.gridXEntry.set_text("10")        self.gridXEntry.set_width_chars(3)        self.hBox1.pack_start(self.gridXEntry, False, True, 5)        #        Grid y label        self.gridYLabel = gtk.Label("y:")        self.hBox1.pack_start(self.gridYLabel, False, True, 0)        #        Grid y entry        self.gridYEntry = gtk.Entry(0)        self.gridYEntry.set_text("1")        self.gridYEntry.set_width_chars(3)        self.hBox1.pack_start(self.gridYEntry, False, True, 5)        #        Grid y label        self.gridUnitLabel = gtk.Label("GRID_UNIT:")        self.hBox1.pack_start(self.gridUnitLabel, False, True, 0)                #        Grid y entry        self.gridUnitEntry = gtk.Entry(0)        self.gridUnitEntry.set_text("10")        self.gridUnitEntry.set_width_chars(3)        self.hBox1.pack_start(self.gridUnitEntry, False, True, 5)        self.hBox2 = gtk.HBox(False, 2)        #        Load button        self.openButton = gtk.Button("Load topology")        self.hBox2.pack_start(self.openButton, False, True, 0)        self.openButton.show()        #        Save button        self.writeButton = gtk.Button("Save topology")        self.hBox2.pack_start(self.writeButton, False, True, 0)        self.writeButton.show()                #        Generate topology button        self.genButton = gtk.Button("Generate topology")        self.hBox2.pack_start(self.genButton, False, True, 0)        self.genButton.show()                #        Communication On/Off button        self.openLogButton = gtk.Button("All communication: Off")        self.hBox2.pack_start(self.openLogButton, False, True, 0)        self.openLogButton.show()                    #        Radius checkButton        self.showRadius = gtk.CheckButton("Radius")        self.showRadius.set_active(False)        self.hBox2.pack_start(self.showRadius, True, True, 0)        self.showRadius.show()        #        Link Layer checkButton                self.generateLinkLayer = gtk.CheckButton("Use LinkLayer")        self.generateLinkLayer.set_active(False)        self.hBox2.pack_start(self.generateLinkLayer, True, True, 0)        self.generateLinkLayer.show()        self.vBox1.pack_start(self.hBox2, False, True, 0)        self.hBox2.show()        self.hBox3 = gtk.HBox(False, 2)        #        Play button        self.playButton = gtk.Button("Play")        self.playButton.set_sensitive(True)        self.hBox3.pack_start(self.playButton, False, True, 0)        # self.playButton.show()        #        Pause button        self.pauseButton = gtk.Button("Pause")        self.pauseButton.set_sensitive(False)        self.hBox3.pack_start(self.pauseButton, False, True, 0)        # self.pauseButton.show()        #        Step button        self.stepButton = gtk.Button("Step")        self.stepButton.set_sensitive(False)        self.hBox3.pack_start(self.stepButton, False, True, 0)        self.stepButton.show()        #        Speed combo        self.listStore = gtk.ListStore(gobject.TYPE_STRING)        self.speedCombo = gtk.combo_box_new_text()        self.speedCombo.append_text("10ms")        self.speedCombo.append_text("50ms")        self.speedCombo.append_text("100ms")        self.speedCombo.append_text("500ms")        self.speedCombo.append_text("2000ms")        self.speedCombo.append_text("5000ms")        self.speedCombo.append_text("9000ms")        self.speedCombo.append_text("100000ms")                self.speedCombo.set_active(1)                self.hBox3.pack_start(self.speedCombo, False, True, 0)        self.speedCombo.show()                    #        Separator 4        self.separator4 = gtk.VSeparator()        self.hBox3.pack_start(self.separator4, False, True, 10)        self.separator4.show()        #        Generate button                self.vBox1.pack_start(self.hBox3, False, True, 0)        self.hBox3.show()                #        Show debug        self.debugChannelsButton = gtk.Button("Debug channels")        self.hBox3.pack_start(self.debugChannelsButton, False, True, 0)        self.debugChannelsButton.show()                #        Show variable        self.breakpointButton = gtk.Button("Breakpoints")        self.hBox3.pack_start(self.breakpointButton, False, True, 0)        self.breakpointButton.show()                #        Variables        self.addNodeButton = gtk.Button("Variables")        self.hBox3.pack_start(self.addNodeButton, False, True, 0)        self.addNodeButton.show()                #        Record        self.recordButton = gtk.Button("Records")        self.hBox3.pack_start(self.recordButton, False, True, 0)        self.recordButton.show()                #        Record        self.sendPacketButton = gtk.Button("Send packet")        self.hBox3.pack_start(self.sendPacketButton, False, True, 0)        self.sendPacketButton.show()#        self.vBox1.pack_start(self.hBox3, False, True, 0)#        self.hBox3.show()#       /hBox3        self.hBox.pack_start(self.vBox1, False, True, 0)                self.vBox1.show()#       /vBox1#       vBox4        self.vBox4 = gtk.VBox(False, 0)#        Random radioButton        self.randomRadioButton = gtk.RadioButton(None, "Random")        self.vBox4.pack_start(self.randomRadioButton, False, True, 0)        self.randomRadioButton.show()#        Max radioButton        self.maxRadioButton = gtk.RadioButton(self.randomRadioButton, "Max")        self.vBox4.pack_start(self.maxRadioButton, False, True, 0)        self.maxRadioButton.show()#        Coherent radioButton3        self.coherentRadioButton = gtk.RadioButton(self.randomRadioButton, "Coherent")        self.vBox4.pack_start(self.coherentRadioButton, False, True, 0)        self.coherentRadioButton.show()        self.hBox.pack_start(self.vBox4, False, True, 0)        self.vBox4.show()#        Grid radioButton        self.gridRadioButton = gtk.RadioButton(self.randomRadioButton, "Grid")        self.vBox4.pack_start(self.gridRadioButton, False, True, 0)        self.gridRadioButton.show()        #        Grid radioButton        self.uniformRadioButton = gtk.RadioButton(self.randomRadioButton, "Uniform")        self.vBox4.pack_start(self.uniformRadioButton, False, True, 0)                self.vBox.pack_start(self.hBox, False, True, 0)        self.hBox.show()        #        Screen        self.screen = Screen()        self.vBox.pack_start(self.screen, True, True, 0)        self.screen.show()        self.window.add(self.vBox)        self.vBox.show()        self.window.show()        #        Connecting window with functions        self.window.connect("destroy", gtk.main_quit)        self.window.connect("configure-event", self.showSize)        self.window.connect("button-press-event", self.screen.showNodeInfo)                #        Connecting buttons with functions                self.genButton.connect("clicked", self.generate, None)        self.writeButton.connect("clicked", self.screen.writeTopology, None)                self.openLogButton.connect("clicked", self.communcationOnOff, None)        self.visualisationOff.connect("toggled", self.visualisationOnOff, None)                self.playButton.connect("clicked", self.playTossim, None)        self.pauseButton.connect("clicked", self.screen.pauseTossimLog, None)        self.stepButton.connect("clicked", self.stepTossim, None)        self.openButton.connect("clicked", self.openTopology, None)        self.showRadius.connect("toggled", self.setShowRadius, None)        self.generateLinkLayer.connect("toggled", self.setLinkLayerModel, None)                #        Connecting radioButtons with functions        self.randomRadioButton.connect("toggled", self.setMethod, 1)        self.maxRadioButton.connect("toggled", self.setMethod, 2)        self.coherentRadioButton.connect("toggled", self.setMethod, 3)        self.gridRadioButton.connect("toggled", self.setMethod, 4)        self.uniformRadioButton.connect("toggled", self.setMethod, 5)        self.speedCombo.connect("changed", self.setSpeed, None)                        # Set self.appName         appxml = open("app.xml", "r")            for line in appxml:            if "<component qname=" in line:                                self.appName = line[line.find('="')+2:line.find('" ')]                    break        self.appName = self.appName.replace("App", "")        self.screen.appName = self.appName                          # Get list of all TinyOS variables used in application        tossimVariables = str(n.variables)        tossimVariables = tossimVariables.replace(" ", "\t")        tossimVariables = tossimVariables.split("\t")                self.screen.variableList = []                self.screen.variableAllList = {}        for line in tossimVariables:             if len(line) > 1:                         model = line[:line.find(".")].strip()                var = line[line.find(".")+1:].strip()                            if var[-1] == ":":                    var = var[:-1]                                if len(var) > 0:                    self.screen.variableAllList[var] = model                                        self.noiseList = []        self.debugList = []        self.screen.recordVariableList = []        self.screen.recorded = []        self.breakpointList = [] # [[nodeid/all, variable, condition, value],[..]]          self.debugIsOn = True                self.securityStepCounter = 0;                    self.breakpointScript = None                self.debugChannelsButton.connect("clicked", self.channelsDebugDialog, None)        self.breakpointButton.connect("clicked", self.breakpointDialog, None)        self.addNodeButton.connect("clicked", self.variablesDialog, None)        self.recordButton.connect("clicked", self.recordDialog, None)        self.sendPacketButton.connect("clicked", self.sendPacket, None)                        #    Read configuration file        self.initSimVizConfig()        #    Read configuration values from "SimViz/SimVizConfig"    def initSimVizConfig(self):        try:            simVizConfig = open("Simviz/SimVizConfig", "r")            file = simVizConfig.read()            row = file.split("\n")            for i in row:                                fields = i.split("\t")                                      # Read debug channels from config                  if fields[0] == "debug-channels":                                        fields.remove(fields[0])                                        for field in fields:                        self.debugList.append(field);                                # Read breakpoints                if fields[0] == "breakpoint":                    if len(fields) == 5:                                         breakpoint = [fields[1], fields[2], fields[3], fields[4], False]                        self.breakpointList.append(breakpoint)                    if len(fields) >= 9:                           breakpoint = [fields[1], fields[2], fields[3], fields[4], False, fields[5], fields[6], fields[7], fields[8]]                        self.breakpointList.append(breakpoint)                                                                               # Read list of variables from config                  if fields[0] == "variables":                                        fields.remove(fields[0])                                        for field in fields:                        self.screen.variableList.append(field);                                # Read list of recorded variables                   if fields[0] == "record-variable":                                                            record = [fields[1], fields[2]]                    self.screen.recordVariableList.append(record);                                                    if len(self.screen.variableList) <= 0:                for i in self.screen.variableAllList:                                        if self.screen.variableAllList[i] == self.appName:                        self.screen.variableList.append(i)                                                   simVizConfig.close()            print "SimViz successfully loaded."            print "Debug channels: " + str(self.debugList)                        print "Breakpoints: " + str(self.breakpointList)            print "Variables: " + str(self.screen.variableList)            print "Recording: " + str(self.screen.recordVariableList)                    except Exception, e:            print "Missing SimVizConfig file: 'Simviz/SimVizConfig'";            print e;        # Save current values to Config file ("SimViz/SimVizConfig")    def saveSimVizConfig(self):        try:            simVizConfig = open("Simviz/SimVizConfig", "w")                        #    Save debug list            if len(self.debugList) > 0:                simVizConfig.write("debug-channels")                for field in self.debugList:                    simVizConfig.write("\t" + str(field))                simVizConfig.write("\n")                                    #    Save breakpoint list            if len(self.breakpointList) > 0:                for field in self.breakpointList:                    simVizConfig.write("breakpoint")                    simVizConfig.write("\t" + str(field[0]) + "\t" + str(field[1]) + "\t" + str(field[2]) + "\t" + str(field[3]))                    if len(field) >= 9:                            simVizConfig.write("\t" + str(field[5]) + "\t" + str(field[6]) + "\t" + str(field[7]) + "\t" + str(field[8]))                    simVizConfig.write("\n")                             #    Save record variables list            if len(self.screen.recordVariableList) > 0:                for field in self.screen.recordVariableList:                    simVizConfig.write("record-variable")                    simVizConfig.write("\t" + str(field[0]) + "\t" + str(field[1]))                    simVizConfig.write("\n")                                    #    Save variable list            if len(self.screen.variableList) > 0:                                simVizConfig.write("variables")                for field in self.screen.variableList:                    simVizConfig.write("\t" + str(field))                simVizConfig.write("\n")                                                        simVizConfig.close()        except Exception, e:            print "Couldn`t save SimVizConfig file: 'Simviz/SimVizConfig'";                    # base this on a message dialog    def responseToDialog(entry, dialog, response):        dialog.response(response)    #    Dialog: Managing of displayed VARIABLES    def variablesDialog(self, widget, data):              dialog = gtk.MessageDialog(            None,            gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,            gtk.MESSAGE_INFO,            gtk.BUTTONS_OK,            None)        dialog.set_markup('Manage displayed variables during simulation:')        dialog.set_title('Variables')        self.listStore = gtk.ListStore(gobject.TYPE_STRING)        self.cbRemove = gtk.combo_box_new_text()        self.cbAdd = gtk.combo_box_new_text()                    self.cbRecords = gtk.combo_box_new_text()        self.cbNode = gtk.combo_box_new_text()                self.cbRemove.append_text("Displayed variables")        for i in self.screen.variableList:                        self.cbRemove.append_text(i)                    self.cbAdd.append_text("All variables")        for i in self.screen.variableAllList:            if not i in self.screen.variableList:                self.cbAdd.append_text(i)                self.cbRecords.append_text("Record variables")        for i in self.screen.recordVariableList:                        self.cbRecords.append_text(i[0] + " (Node: " + str(i[1]) + ")")                self.cbNode.append_text("Node ID to record")        for i in range(0, self.numberOfNodes):                        self.cbNode.append_text(str(i))                    self.cbRemove.set_active(0)        self.cbNode.set_active(0)        self.cbAdd.set_active(0)            self.cbRecords.set_active(0)                               entry = gtk.Entry()                hbox = gtk.HBox()                            hbox.pack_start(self.cbRecords, True, 5, 5)        stopRecording =  gtk.Button("Stop recording")        hbox.pack_start(stopRecording, False, 5, 5)        dialog.vbox.pack_end(hbox, True, True, 0)                hbox = gtk.HBox()                dialog.vbox.pack_end(hbox, True, True, 0)        hbox = gtk.HBox()                dialog.vbox.pack_end(hbox, True, True, 0)                        hbox = gtk.HBox()                hbox.pack_start(self.cbAdd, True, 5, 5)        addVariableButton =  gtk.Button("Add variable")        hbox.pack_start(addVariableButton, False, 5, 5)        dialog.vbox.pack_end(hbox, True, True, 0)                hbox = gtk.HBox()                dialog.vbox.pack_end(hbox, True, True, 0)        hbox = gtk.HBox()                dialog.vbox.pack_end(hbox, True, True, 0)            hbox = gtk.HBox()                            hbox.pack_start(self.cbNode, False, 5, 5)        self.addRecordButton =  gtk.Button("Start recording")                        hbox.pack_start(self.addRecordButton, False, 5, 5)        dialog.vbox.pack_end(hbox, True, True, 0)                      hbox = gtk.HBox()        hbox.pack_start(self.cbRemove, True, 5, 5)        removeVariableButton =  gtk.Button("Remove variable")                hbox.pack_start(removeVariableButton, False, 5, 5)                dialog.vbox.pack_end(hbox, True, True, 0)                self.addRecordButton.set_sensitive(False)                                removeVariableButton.connect("clicked", self.removeVariable, None)        addVariableButton.connect("clicked", self.addVariable, None)        stopRecording.connect("clicked", self.recordRemove, None)        self.addRecordButton.connect("clicked", self.recordAdd, None)        self.cbNode.connect('changed', self.recordCbChanged, None)        self.cbRemove.connect('changed', self.recordCbChanged, None)                        dialog.show_all()        addVariableButton.show()        self.cbAdd.show()        self.cbRemove.show()                dialog.run()        text = entry.get_text()        dialog.destroy()        return text        #    Dialog: Managing of RECORDED VARIABLES    def recordDialog(self, widget, data):            dialog = gtk.MessageDialog(None,            gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,            gtk.MESSAGE_INFO,            gtk.BUTTONS_OK,            None)                dialog.set_title("Recorded variables")                                                     #        Step button                stepButton = gtk.Button("Step")        self.recordExportButton = gtk.Button("Export records")                        self.cbRecord = gtk.combo_box_new_text()        self.cbVariables = gtk.combo_box_new_text()                        self.cbVariables.append_text("Filter by: All")        for i in self.screen.recordVariableList:                        self.cbVariables.append_text(i[0] + " at node: " + str(i[1]))        self.cbVariables.set_active(0)                self.cbRecord.append_text("Records")                        for r in self.screen.recorded:                        self.cbRecord.insert_text(0, str(r[0]) + " (node " + str(r[1]) + "):     " + str(r[2]) + "     cykle: " + str(r[3])+ "")        self.cbRecord.set_active(0)           vbox = gtk.VBox()                        vbox.pack_start(self.cbVariables, False, 5, 5)        self.cbVariables.show()                             vbox.pack_start(self.cbRecord, True, 80, 5)        self.cbRecord.show()                                    vbox.pack_start(stepButton, False, False, 20)        stepButton.show()                vbox.pack_start(self.recordExportButton, True, True, 10)                self.recordExportButton.show()                dialog.vbox.pack_end(vbox, False, False, 0)                               stepButton.connect("clicked", self.stepTossim, None)        stepButton.connect("clicked", self.recordRefresh, None)        self.recordExportButton.connect("clicked", self.recordExport, None)        self.cbVariables.connect("changed", self.recordRefresh, None)                         dialog.show_all()                dialog.run()            dialog.destroy()       # Refresh list in RECORDED VARIABLES dialog    def recordRefresh(self,widget, data):                model = self.cbRecord.get_model()        model.clear()                index = self.cbVariables.get_active()                model = self.cbVariables.get_model()                active = self.cbVariables.get_active_iter()        variable = model[active][0]                if index == 0:                        for r in self.screen.recorded:                         self.cbRecord.insert_text(0, str(r[0]) + " (node " + str(r[1]) + "):     " + str(r[2]) + "     cyklle: " + str(r[3])+ "")                            else:                        for r in self.screen.recorded:                if r[0] == self.screen.recordVariableList[index-1][0] and r[1] == self.screen.recordVariableList[index-1][1]:                    self.cbRecord.insert_text(0, str(r[0]) + " (node " + str(r[1]) + "):     " + str(r[2]) + "     cyklle: " + str(r[3])+ "")                                                        self.cbRecord.set_active(0)                    # Export RECORDED VARIABLES    def recordExport(self, widget, data):        try:            f = open("Simviz/ExportedRecords.txt","w")            for r in reversed(self.screen.recorded):                f.write(str(r[0]) + " (node " + str(r[1]) + "):     " + str(r[2]) + "     cykle: " + str(r[3])+ "\n")                                    for variable in self.screen.recordVariableList:                f.write("\n\n\nExport of "+ str(variable[0]) + " at node " + str(variable[1]) + " :\n")                for r in reversed(self.screen.recorded):                    if r[0] == variable[0] and r[1] == variable[1]:                        f.write(str(r[0]) + " (node " + str(r[1]) + "):     " + str(r[2]) + "     cykle: " + str(r[3])+ "\n")                                    self.recordExportButton.set_label("Records exported to: Simviz/ExportedRecords.txt")            f.close()        except Exception, e:            self.recordExportButton.set_label("Couldn`t export records")            print "Couldn`t export records to file: 'Simviz/ExportedRecords.txt'";            print e;            # Refresh combo-box in RECORDED VARIABLES dialog                            def recordCbChanged(self, widget, data):        index = self.cbRemove.get_active()        index2 = self.cbNode.get_active()        if index != 0 and index2 != 0:                                                   self.addRecordButton.set_sensitive(True)                    else:            self.addRecordButton.set_sensitive(False)                   # Add RECORDED VARIABLE    def recordAdd(self, widget, data):                    model = self.cbRemove.get_model()        active = self.cbRemove.get_active_iter()        variable = model[active][0];                nodeid = self.cbNode.get_active()-1                                        self.screen.recordVariableList.append([variable,str(nodeid)])        self.addRecordButton.set_sensitive(False)        self.cbRecords.append_text(variable + " (Node: " + str(nodeid) + ")")                       appName = self.screen.variableAllList[variable]        self.tossimVariables[(str(nodeid), variable)] = self.tossimNodes[int(nodeid)].getVariable(appName + "." + variable)        self.screen.recordedLast[(variable, str(nodeid))] = -99999                self.saveSimVizConfig()            # Remove RECORDED VARIABLE    def recordRemove(self, widget, data):                model = self.cbRecords.get_model()        active = self.cbRecords.get_active_iter()        variable = model[active][0]        index = self.cbRecords.get_active()                if index != 0:                  self.screen.recordVariableList.remove(self.screen.recordVariableList[index-1])                          self.cbRecords.set_active(0)                  self.cbRecords.remove_text(index)                                   self.saveSimVizConfig()    # Remove VARIABLE from list of variables    def removeVariable(self, widget, data):        model = self.cbRemove.get_model()        active = self.cbRemove.get_active_iter()        variable = model[active][0]        index = self.cbRemove.get_active()        if index != 0:                  self.screen.variableList.remove(variable)              self.cbRemove.set_active(0)                  self.cbRemove.remove_text(index)               self.cbAdd.append_text(variable)        self.saveSimVizConfig()    # Add VARIABLE to list of variables            def addVariable(self, widget, data):                model = self.cbAdd.get_model()        active = self.cbAdd.get_active_iter()        variable = model[active][0]        index = self.cbAdd.get_active()        if index != 0:                  self.screen.variableList.append(variable)              self.cbAdd.set_active(0)                  self.cbAdd.remove_text(index)               self.cbRemove.append_text(variable)           self.saveSimVizConfig()             def main(self):        gtk.main()                               # Dialog: Editing Debugging channels        def channelsDebugDialog(self, widget, data):              dialog = gtk.MessageDialog(            None,            gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,            gtk.MESSAGE_INFO,            gtk.BUTTONS_CLOSE,            None)        dialog.set_markup('Add / Remove channels:')        dialog.set_title('Debug channels manager')        self.listStore = gtk.ListStore(gobject.TYPE_STRING)        self.cbRemoveChannel = gtk.combo_box_new_text()        self.addChannelName = gtk.Entry(0)        self.cbRemoveChannel.append_text("Choose channel to remove")        for i in self.debugList:                        self.cbRemoveChannel.append_text(i)        self.cbRemoveChannel.set_active(0)                                    self.addChannelName.set_text("")                hbox = gtk.HBox()                        hbox.pack_start(self.cbRemoveChannel, True, 5, 5)        removeVariableButton =  gtk.Button("Remove channel")        hbox.pack_start(removeVariableButton, False, 5, 5)        dialog.vbox.pack_end(hbox, True, True, 0)                        hbox = gtk.HBox()                hbox.pack_start(self.addChannelName, True, 5, 5)        addVariableButton =  gtk.Button("Add channel")        hbox.pack_start(addVariableButton, False, 5, 5)                dialog.vbox.pack_end(hbox, True, True, 0)                removeVariableButton.connect("clicked", self.channelRemove, None)        addVariableButton.connect("clicked", self.channelAdd, None)                dialog.show_all()        addVariableButton.show()                removeVariableButton.show()                dialog.run()        dialog.destroy()        # Remove DEBUGGING channel    def channelRemove(self, widget, data):        model = self.cbRemoveChannel.get_model()        active = self.cbRemoveChannel.get_active_iter()        variable = model[active][0]        index = self.cbRemoveChannel.get_active()        if index != 0:                  self.debugList.remove(variable)            self.cbRemoveChannel.remove_text(index)              self.cbRemoveChannel.set_active(0)              t.removeChannel(variable, sys.stdout)                    self.saveSimVizConfig()        print "Debug channels: " + str(self.debugList)        # Remove DEBUGGING channel    def channelAdd(self, widget, data):        addChannel = self.addChannelName.get_text();        if len(addChannel) > 0 and not addChannel in self.debugList:            self.debugList.append(addChannel)                                    self.cbRemoveChannel.append_text(addChannel)                    t.addChannel(addChannel, sys.stdout)          self.saveSimVizConfig()        print "Debug channels: " + str(self.debugList)    # Dialog: Managing BREAKPOINTS    def breakpointDialog(self, widget, data):                  dialog = gtk.MessageDialog(            None,            gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,            gtk.MESSAGE_INFO,            gtk.BUTTONS_CLOSE,            None)        dialog.set_markup('Manage breakpoints:')        dialog.set_title('Breakpoint manager')                self.cbBreakpoints = gtk.combo_box_new_text()                        #    Breakpoint Node        self.cbBreakpointNode = gtk.combo_box_new_text()        self.cbBreakpointNode.append_text("Node")        self.cbBreakpointNode.append_text("All")        for i in range(self.numberOfNodes):            self.cbBreakpointNode.append_text(str(i))        self.cbBreakpointNode.set_active(0)                            #    Breakpoint variable        self.cbBreakpointVar = gtk.combo_box_new_text()        self.cbBreakpointVar.append_text("  Variable  ")                for i in self.screen.variableList:            self.cbBreakpointVar.append_text(i)        self.cbBreakpointVar.set_active(0)                #    Breakpoint operation        self.cbBreakpointOperation = gtk.combo_box_new_text()        self.cbBreakpointOperation.append_text("==")        self.cbBreakpointOperation.append_text("!=")        self.cbBreakpointOperation.append_text(">")        self.cbBreakpointOperation.append_text("<")        self.cbBreakpointOperation.append_text(">=")        self.cbBreakpointOperation.append_text("<=")        self.cbBreakpointOperation.set_active(0)        #    Breakpoint variable                self.cbBreakpointValue = gtk.Entry(0)              self.cbBreakpointValue.set_width_chars(5)                  self.breakpointComboRefresh(0)                                                    hbox = gtk.HBox()                        self.activateButton =  gtk.Button("Activate / Deactivate")        hbox.pack_start(self.activateButton, False, 5, 5)        removeVariableButton =  gtk.Button("Remove breakpoint")                hbox.pack_start(removeVariableButton, False, 5, 5)                self.breakpointAndButton =  gtk.Button("Merge breakpoints (AND)")        self.breakpointAndButton.set_sensitive(False)        hbox.pack_start(self.breakpointAndButton, False, 5, 5)                dialog.vbox.pack_end(hbox, True, True, 0)                hbox = gtk.HBox()                        hbox.pack_start(self.cbBreakpoints, True, 5, 5)        dialog.vbox.pack_end(hbox, True, True, 0)                hbox = gtk.HBox()                                dialog.vbox.pack_end(hbox, True, True, 0)        hbox = gtk.HBox()                                dialog.vbox.pack_end(hbox, True, True, 0)                        hbox = gtk.HBox()                hbox.pack_start(self.cbBreakpointNode, True, 5, 5)        hbox.pack_start(self.cbBreakpointVar, True, 5, 5)        hbox.pack_start(self.cbBreakpointOperation, True, 5, 5)        hbox.pack_start(self.cbBreakpointValue, True, 5, 5)        self.breakpointAddButton =  gtk.Button("Add breakpoint")        hbox.pack_start(self.breakpointAddButton, False, 5, 5)        self.breakpointAddButton.set_sensitive(False)              dialog.vbox.pack_end(hbox, True, True, 0)                                removeVariableButton.connect("clicked", self.breakpointRemove, None)        self.cbBreakpoints.connect('changed', self.breakpointCbChanged, None)         self.cbBreakpointNode.connect('changed', self.breakpointControl, None)        self.cbBreakpointVar.connect('changed', self.breakpointControl, None)        self.cbBreakpointValue.connect('changed', self.breakpointControl, None)                self.breakpointAddButton.connect("clicked", self.breakpointAdd, None)        self.breakpointAndButton.connect("clicked", self.breakpointAdd, "and")        self.activateButton.connect("clicked", self.breakpointActivate, None)                                  dialog.show_all()                dialog.run()        dialog.destroy()             # Add Breakpoint    def breakpointAdd(self, widget, data):        value = self.cbBreakpointValue.get_text()                  model = self.cbBreakpointNode.get_model()        active = self.cbBreakpointNode.get_active_iter()        node = model[active][0];                model = self.cbBreakpointOperation.get_model()        active = self.cbBreakpointOperation.get_active_iter()        operation = model[active][0];                model = self.cbBreakpointVar.get_model()        active = self.cbBreakpointVar.get_active_iter()        variable = model[active][0];                        # Merge (AND) two conditions            if data == "and":            index = self.cbBreakpoints.get_active()            if index != 0:                self.breakpointList[index-1] = self.breakpointList[index-1] + [node, variable, operation, value]                                appName = self.screen.variableAllList[variable]                self.tossimVariables[(str(node),variable)] = self.tossimNodes[int(node)].getVariable(appName + "." + variable)                           self.breakpointComboRefresh(index)                     else:            self.breakpointList.append([node,variable,operation, value, False])                                               self.breakpointComboRefresh(len(self.breakpointList))            appName = self.screen.variableAllList[variable]            if node != "All":                self.tossimVariables[(str(node),variable)] = self.tossimNodes[int(node)].getVariable(appName + "." + variable)            else:                for i in range(0,self.numberOfNodes):                    appName = self.screen.variableAllList[variable]                    self.tossimVariables[(str(i),variable)] = self.tossimNodes[int(i)].getVariable(appName + "." + variable)                    print str(self.tossimVariables)        self.breakpointAddButton.set_sensitive(False)                self.saveSimVizConfig()                         # Refresh Combo-box in BREAKPOINT dialog            def breakpointComboRefresh(self, position):                                            if position > 0:                        for i in range(0,len(self.breakpointList) + 1):                self.cbBreakpoints.remove_text(0)                self.cbBreakpoints.append_text("List of breakpoints")                            for i in self.breakpointList:                                                string = "Node: " + str(i[0]) + ", " + str(i[1]) + " " + str(i[2]) + " " + str(i[3])                         if len(i) >= 9:                string += "  AND  Node: " + str(i[5]) + ", " + str(i[6]) + " " + str(i[7]) + " " + str(i[8])            if i[4]:                 string += " (Deactive)"            else:                 string += " (Active)"                            self.cbBreakpoints.append_text(string)                self.cbBreakpoints.set_active(position)                        # Make BREAKPOINT active        def breakpointActivate(self, widget, data):        index = self.cbBreakpoints.get_active()        if index != 0:                       self.breakpointList[index-1][4] = not self.breakpointList[index-1][4]                        self.breakpointComboRefresh(index)        # Remove BREAKPOINT    def breakpointRemove(self, widget, data):        index = self.cbBreakpoints.get_active()        if index != 0:                           self.breakpointList.remove(self.breakpointList[index-1])            self.cbBreakpoints.remove_text(index)                        self.cbBreakpoints.set_active(0)        self.saveSimVizConfig()            # Combo-box in BREAKPOINT dialog refresh        def breakpointCbChanged(self, widget, data):        index = self.cbBreakpoints.get_active()        if index != 0:                                   # Activate / Deactivate            if self.breakpointList[index-1][4]:                                          self.activateButton.set_label("Activate")                              else:                self.activateButton.set_label("Deactivate")                                            # AND button active deactive            if len(self.breakpointList[index-1]) >= 9:                self.breakpointAndButton.set_sensitive(False)            else:                self.breakpointControl(None, None)                else:            self.breakpointAndButton.set_sensitive(False)            self.activateButton.set_label("Activate / Deactivate")        def breakpointControl(self, widget, data):                indexNode = self.cbBreakpointNode.get_active()        indexVar = self.cbBreakpointVar.get_active()        value = self.cbBreakpointValue.get_text()                        if indexNode != 0 and indexVar != 0 and len(value) > 0:                                               self.breakpointAddButton.set_sensitive(True)            index = self.cbBreakpoints.get_active()                    if index >  0:                if len(self.breakpointList[index-1]) >= 9 or indexNode == 1:                   self.breakpointAndButton.set_sensitive(False)                else:                    self.breakpointAndButton.set_sensitive(True)        else:            self.breakpointAddButton.set_sensitive(False)            self.breakpointAndButton.set_sensitive(False)    # Send Packet to the TOSSIM network, see file "Simviz/SendPacketScript.py"    def sendPacket(self, widget, data):        try:                    f = open("Simviz/SendPacketScript.py","r")            sendPacketScript = f.read()                                    f.close()                        self.sendPacketButton.set_label("  Sended  ")            exec sendPacketScript                 except Exception, e:            self.sendPacketButton.set_label("Couldn`t send")            print "Couldn`t send Packet, problem in script: 'Simviz/SendPacketScript.py'";            print e;                # Turn on/off the visualisation             def visualisationOnOff(self, widget, data):                if self.screen.visualisationIsOn:            self.screen.visualisationIsOn = False            self.screen.visitedTuple = []            self.visualisationOff.set_active(True)            print "change to False"        else :                                    self.screen.visualisationIsOn = True            self.screen.visitedTuple = []                                   self.visualisationOff.set_active(False)            print "change to True"            # Turn on/off the communication             def communcationOnOff(self, widget, data):        if self.screen.communicationIsOn:            self.screen.communicationIsOn = False            self.screen.visitedTuple = []            self.openLogButton.set_label("Communication: Off")            else :                                    self.screen.communicationIsOn = True            self.screen.visitedTuple = []                                    self.openLogButton.set_label("Communication: On")                     def returnVariable(self, node, name):        m = t.getNode(node)        v = m.getVariable(self.appName + "." + name)        return v.getData()        #    #    Make a step in TOSSIM simulation     #    def stepTossim(self, widget, data):                       print "Start of " + str(self.screen.speed) + " cykles ...";             breakpointOutput = ""         self.screen.visitedTuple = []                 #   Security test         if self.screen.isSecurityTest and False:            print "Security test"                                            else:                stop = False                                     #    Read breakpoint script, See file "Simviz/BreakpointScript.py"            f = open("Simviz/BreakpointScript.py","r")            self.breakpointScript = f.read()                        f.close()                               # MAIN CYKLE            for i in range(0, self.screen.speed):                            t.runNextEvent()                self.tossimCykle = self.tossimCykle + 1                                                #    RECORD variables                if len(self.screen.recordVariableList) > 0:                    for record in self.screen.recordVariableList:                        value = self.tossimVariables[(record[1], record[0])].getData()                                                                        if value != self.screen.recordedLast[(record[0], record[1])]:                            self.screen.recordedLast[(record[0], record[1])] = value                                                                             self.screen.recorded.append([record[0], record[1], value, self.tossimCykle])                # Run breakPoint script                try:                    exec self.breakpointScript                except Exception, e:                                        print "Wrong breakpoint script: 'Simviz/BreakpointScript.py'";                    print e;                                                                        #     Check for BREAKPOINTS                for breakpoint in self.breakpointList:                    if not breakpoint[4]:                        nId = breakpoint[0]                                                   # Simple ALL condition                        cykle = 1                        if nId == "All":                            cykle = self.numberOfNodes                                                # Simple condition                        nId = breakpoint[0]                                        vName = (nId,breakpoint[1])                        vCondition = breakpoint[2]                        vValue = int(breakpoint[3])                                                             #    Do 1 cykle or All cykles                        for i in range(0, cykle):                            if nId == "All":                                nId = i                                                vName = (str(i),breakpoint[1])                                                                                                                    if vCondition == ">":                                                                      # tossimVariables = {(node, variable) = getVariable(), ...}                                if self.tossimVariables[vName].getData() > vValue:                                                          stop = True                                                                elif vCondition == "<":                                if self.tossimVariables[vName].getData() < vValue:                                                            stop = True                                                                elif vCondition == "==":                                if self.tossimVariables[vName].getData() == vValue:                                                            stop = True                                                                elif vCondition == "!=":                                if self.tossimVariables[vName].getData() != vValue:                                                            stop = True                                                                elif vCondition == ">=":                                if self.tossimVariables[vName].getData() >= vValue:                                                            stop = True                                                                elif vCondition == "<=":                                if self.tossimVariables[vName].getData() <= vValue:                                                            stop = True                                                                                                                                                                    # INNER seccond level  AND condition                            if stop == True and len(breakpoint) >= 9:                                nId = breakpoint[5]                                                vName = (nId,breakpoint[6])                                vCondition = breakpoint[7]                                vValue = int(breakpoint[8])                                                                                                 stop = False                                                                                            if vCondition == ">":                                                                          if self.tossimVariables[vName].getData() > vValue:                                                              stop = True                                        break                                elif vCondition == "<":                                    if self.tossimVariables[vName].getData() < vValue:                                                                stop = True                                        break                                elif vCondition == "==":                                     if self.tossimVariables[vName].getData() == vValue:                                                                 stop = True                                         break                                                                                                                elif vCondition == "!=":                                    if self.tossimVariables[vName].getData() != vValue:                                                                stop = True                                        break                                elif vCondition == ">=":                                    if self.tossimVariables[vName].getData() >= vValue:                                                                stop = True                                        break                                    elif vCondition == "<=":                                    if self.tossimVariables[vName].getData() <= vValue:                                                                stop = True                                        break                                                                    if stop:                                                        breakpoint[4] = True                                                        breakpointOutput = "Breakpoint (node "+ str(nId) + "): " + str(vName) + " " + vCondition +  " " + str(vValue) + " = " + str(self.tossimVariables[vName].getData()) + "\n" + str(breakpoint)                             break                 if stop:                    break                                                if self.screen.isSecurityTest:            self.screen.numberOfCykles = self.returnVariable(self.screen.pandaNode, "counter")                            self.screen.drawingTimer(self.tempFile, self.nodeList)                 if len(breakpointOutput) > 0:            print breakpointOutput                                     #    #    START of the tossim simulation    #    called automatically after Loading Topology    def playTossim(self, widget, data):        self.stepButton.set_sensitive(True)              self.screen.recorded = []    # (Variable , Node, Value, Cykle)        self.screen.recordedLast = {} # (Variable , Node) = value        self.tossimNodes = [] # [1,2,3..]                 self.tossimVariables = {} # {(node, variable) = getVariable(), ...}        self.tossimCykle = 0                                   generatedScript = open("Simviz/GeneratedScript.py", "w")        self.tempFile = open("Simviz/tmp.txt", "w+")                #      Update elements according informations        self.nodeList = self.screen.nodeList        self.numberOfNodes = self.screen.numberOfMotes        #        self.radius = self.screen.radius        self.numberEntry.set_text(str(self.numberOfNodes))        self.radiusEntry.set_text(str(self.radius))        #       Erasing data from the previous animation        self.screen.com = False                    # Prepare LinkLayer model        self.screen.nodesMemory = {}                                                                                                                                    # Link Gain read        f = open("linkgain.out","r")        linkgaion = f.read()        row = linkgaion.split("\n")        for i in row:            fields = i.split("\t")            if fields[0] == "noise":                minusint = fields[2].split(".")                self.noiseList.insert(int(fields[1]), minusint[0])                             generatedScript.write("import os\nimport sys\nsys.path.append('/opt/tinyos-2.0.2/support/sdk/python/')\nfrom TOSSIM import *\nfrom tinyos.tossim.TossimApp import *\n\nn = NescApp()\nt = Tossim(n.variables.variables())\nr = t.radio()\n\n")                                            r = t.radio()                                 #     Debug channels        t.addChannel("SimViz", self.tempFile)         for debug in self.debugList:            t.addChannel(debug, sys.stdout)                        generatedScript.write("t.addChannel('" + debug + "', sys.stdout)\n")                            for n in self.screen.allConnections:            r.add(n[0][0], n[0][1], n[1])                        generatedScript.write("r.add(" + str(n[0][0]) + ","+ str(n[0][1]) + ", " + str(n[1]) + ")\n")                    #       AddNoiseTrace        noise = open("Simviz/meyer-heavy.txt", "r")        lines = noise.readlines()        noise.close()        for line in lines:                 str1 = line.strip()            if str1:                val = int(str1)                for i in range(self.numberOfNodes):                                          t.getNode(i).addNoiseTraceReading(val)                    generatedScript.write("t.getNode(" + str(i) + ").addNoiseTraceReading("+ str(val) +")\n")                           #       CreateNoiseModel part        for i in range(0, self.numberOfNodes):            t.getNode(i).createNoiseModel()             generatedScript.write("t.getNode(" + str(i) + ").createNoiseModel()\n")                                     #       BootAtTime part        for i in range(0, self.numberOfNodes):                        randd = random() * 1000            t.getNode(i).bootAtTime(randd)                        generatedScript.write("t.getNode(" + str(i) + ").bootAtTime(" + str(randd) + ")\n")                                        #     Prepare tossimNodes for breakpoint etc        for i in range(0,self.numberOfNodes):            self.tossimNodes.insert(i, t.getNode(i))                #     Prepare tossimVariablesNodes for BREAKPOINTs etc                    for breakpoint in self.breakpointList:                # breakpoint[0] = node id                                if breakpoint[0] == "All":                    for i in range(0,self.numberOfNodes):                        appName = self.screen.variableAllList[breakpoint[1]]                        self.tossimVariables[(str(i),breakpoint[1])] = self.tossimNodes[int(i)].getVariable(appName + "." + breakpoint[1])                else:                                                                           appName = self.screen.variableAllList[breakpoint[1]]                    self.tossimVariables[(breakpoint[0],breakpoint[1])] = self.tossimNodes[int(breakpoint[0])].getVariable(appName + "." + breakpoint[1])                    if len(breakpoint) >= 9:                        appName = self.screen.variableAllList[breakpoint[6]]                        self.tossimVariables[(breakpoint[0],breakpoint[6])] = self.tossimNodes[int(breakpoint[5])].getVariable(appName + "." + breakpoint[5])                #    Prepare tosimVariables for RECORDS        for record in self.screen.recordVariableList:            node = record[1]            var = record[0]            appName = self.screen.variableAllList[var]                        self.tossimVariables[(str(node), var)] = self.tossimNodes[int(node)].getVariable(appName + "." + var)                        self.screen.recordedLast[(var, node)] = -99999                                generatedScript.close()                print "Tossim successfully started."#    This method sets speed of visualisation.    def setSpeed(self, widget, data):        try:            model = self.speedCombo.get_model()            active = self.speedCombo.get_active_iter()            if active < 0:                self.screen.speed = 50            else:                if model[active][0] != "CYKLE":                    self.screen.speed = int(model[active][0].rstrip("ms"))                else:                                        self.screen.speed = "CYKLE";                            except Exception, e:            print e#    This method generates topology.    def generate(self, widget, data):#        Erasing all data from previous animation.        self.screen.com = False        self.screen.nodesMemory = {}        self.allNodesList = []#        self.saveProjectButton.set_sensitive(True)        try:            generation = True            self.canvasWidth = int(self.canvasXEntry.get_text())            self.canvasHeight = int(self.canvasYEntry.get_text())            self.windowWidth = int(self.canvasXEntry.get_text()) + self.screen.area.x            self.windowHeight = int(self.canvasYEntry.get_text()) + self.screen.area.y            self.window.resize(self.windowWidth, self.windowHeight)            self.numberOfNodes = int(self.numberEntry.get_text())            self.radius = int(self.radiusEntry.get_text())            self.screen.setParameters(self.radius)            self.finalNodeList = []            #self.screen.currentDrawMethod = self.screen.drawGenerating            self.screen.window.invalidate_rect((0,0,self.screen.area.width,self.screen.area.height),False)            gtk.gdk.window_process_all_updates()                        # LinkLayer generation                        if self.screen.islinkLayerGeneration:                  try:                    os.remove(os.getcwd()+"/topology.out")                    os.remove(os.getcwd()+"/linkgain.out")                except Exception, e:                                        pass                                                                                    linkLayerGenerateConfig = open("Simviz/LinkLayerGenerateConfig", "r")                linkLayerGenerate = open("Simviz/LinkLayerGenerate", "w")                lines = linkLayerGenerateConfig.readlines()                                for line in lines:                   linkLayerGenerate.write(line);                                # Random LinkLayer generation                if self.topologyGenMethod == 1:                                            linkLayerGenerate.write("\n\nTOPOLOGY = 3;\n\n")                                    linkLayerGenerate.write("TERRAIN_DIMENSIONS_X = " + str(self.canvasWidth / 10)  + "; \n")                    linkLayerGenerate.write("TERRAIN_DIMENSIONS_Y = " + str(self.canvasHeight / 10)  + "; \n")                                # Grid                elif self.topologyGenMethod == 4:                                        square = int(math.sqrt(self.numberOfNodes))                    self.numberEntry.set_text(str(square * square))                    self.numberOfNodes = int(self.numberEntry.get_text())                                                                          linkLayerGenerate.write("\n\nTOPOLOGY = 1;\n\n")                    linkLayerGenerate.write("GRID_UNIT = " + str(float(self.gridUnitEntry.get_text()))+";\n\n")                                                                                # Width and Height has to be same                    if self.canvasWidth > self.canvasHeight:                        sameDimension = self.canvasHeight                    else:                        sameDimension = self.canvasWidth                    linkLayerGenerate.write("TERRAIN_DIMENSIONS_X = " + str(sameDimension / 10)  + "; \n")                    linkLayerGenerate.write("TERRAIN_DIMENSIONS_Y = " + str(sameDimension / 10)  + "; \n")                                    # Uniform                                elif self.topologyGenMethod == 5:                    square = int(math.sqrt(self.numberOfNodes))                    self.numberEntry.set_text(str(square * square))                    self.numberOfNodes = int(self.numberEntry.get_text())                                                                         linkLayerGenerate.write("\n\nTOPOLOGY = 2;\n\n")                                        # Width and Height has to be same                    if self.canvasWidth > self.canvasHeight:                        sameDimension = self.canvasHeight                    else:                        sameDimension = self.canvasWidth                    linkLayerGenerate.write("TERRAIN_DIMENSIONS_X = " + str(sameDimension / 10)  + "; \n")                    linkLayerGenerate.write("TERRAIN_DIMENSIONS_Y = " + str(sameDimension / 10)  + "; \n")                linkLayerGenerate.write("NUMBER_OF_NODES = " + str(self.numberOfNodes) + ";\n\n")                                                linkLayerGenerateConfig.close()                linkLayerGenerate.close()                                                                            os.system("java -classpath /opt/tinyos-2.1.0/support/sdk/java/tinyos.jar net.tinyos.sim.LinkLayerModel "+os.getcwd()+"/Simviz/LinkLayerGenerate")#            Random generation            elif self.topologyGenMethod == 1:                self.nodeList = []                while len(self.nodeList) < self.numberOfNodes:                    x = randrange(1, self.canvasWidth - self.nodeSize)                    y = randrange(1, self.canvasHeight - self.nodeSize)                    if not self.nodeList.count((x,y)):                        self.nodeList.append((x, y))                        for i in range(0, len(self.nodeList)):                            x1, y1 = self.nodeList[i]        #                   Choosing nodes which can hear eachother                            if hypot(x1 - x, y1 - y) < self.screen.radius:                                neighboursSet = [(x, y)]                                neighboursSet.append((x1, y1))                                self.finalNodeList.append(neighboursSet)#            Random max neighbours            elif self.topologyGenMethod == 2:                self.nodeList = []                self.maxNeighbours = int(self.neighboursLimitEntry.get_text())                maxGeneration = 0                while len(self.nodeList) < self.numberOfNodes:                    self.breakCall = False#                    When there is no node genrated neither for the 50000 times,#                    process will end                    print maxGeneration                    if maxGeneration > 50000:                            generation = False                            break                    x = randrange(1, self.canvasWidth - self.nodeSize)                    y = randrange(1, self.canvasHeight - self.nodeSize)                    n = 0                    for node in self.nodeList:                        if (node[0] == x) and (node[1] == y):                            self.breakCall = True                            break                    if not self.breakCall:                        self.nodeList.append((x, y, n))                        self.neighbourList = []                        maxGeneration += 1#                        Number of neighbours is checked here. If the new node or#                        any other node have more neighbours then the value#                        of maxNeighbours then the new node is erased.#                        Otherwise new neighbourList with all neighbours#                        is created.                        for i in range(0, len(self.nodeList)):                            x1, y1, n1 = self.nodeList[i]                            if ((x, y, n) != self.nodeList[i]):            #                   Choosing nodes which can hear eachother                                if hypot(x1 - x, y1 - y) < self.screen.radius:                                    if n1 < self.maxNeighbours:                                        if len(self.neighbourList) < self.maxNeighbours:                                            self.neighbourList.append((x1, y1, n1))                                        else:                                            self.neighbourList = []                                            self.nodeList.pop()                                            self.breakCall = True                                            break                                    else:                                        self.neighbourList = []                                        self.nodeList.pop()                                        self.breakCall = True                                        break                            else:                                self.finalNodeList.append([(x, y), (x, y)])#                        If the new node has less or equal number of neighbours,#                        it is added to the neighbourList and all his neighbours#                        will add 1 to the number of theirs neighbours.                        if not self.breakCall:                            maxGeneration = 0                            for node in self.neighbourList:                                index = self.nodeList.index(node)                                x1, y1, n1 = node                                n1 +=1                                self.nodeList.pop(index)                                self.nodeList.insert(index, (x1, y1, n1))                                tempNeighboursList = [(x, y)]                                tempNeighboursList.append((x1, y1))                                self.finalNodeList.append(tempNeighboursList)                                n = len(self.neighbourList)                                self.nodeList.pop()                                self.nodeList.append((x, y, n))                        if maxGeneration > 600000:                            generation = False                            break#            Generating of the coherent map            elif self.topologyGenMethod == 3:                x = randrange(1, self.canvasWidth - self.nodeSize)                y = randrange(1, self.canvasHeight - self.nodeSize)                self.nodeList = [(x, y)]                while len(self.nodeList) < self.numberOfNodes:                    node = self.nodeList[randrange(len(self.nodeList))]                    x0, y0 = node                    x0 += self.nodeSize / 2                    y0 += self.nodeSize / 2#                    Generating of the x coordinates of the neighbour                    if (self.screen.radius - 1) > x0: #if True, the node radio touches the left border                        if (x0 + self.screen.radius) > self.canvasWidth: #if True, the node radio touches the right border                            x = randrange(self.nodeSize / 2, self.canvasWidth - (self.nodeSize / 2)) #the node radio touches left and right border                        else:                            x = randrange((self.nodeSize / 2) + 1, x0 + self.screen.radius - 1) #the node radio touches only the left border                    else: #the node radio doesnt touch the left border                        if (x0 + self.screen.radius) > self.canvasWidth: #if True, the node radio touches only the right border                            x = randrange(x0 - self.screen.radius + 1, self.canvasWidth - (self.nodeSize / 2)) #the node radio touches only the right border                        else:                            x = randrange(x0 - self.screen.radius + 1, x0 + self.screen.radius - 1) #the node radio doesnt touch any border#                    Generating of the y coordinates of the neighbour                    deltaY = round(sqrt(fabs((self.screen.radius * self.screen.radius) - ((x - x0) * (x - x0)))))                    if (y0 - deltaY) < ((self.nodeSize / 2) + 1): # obdelnik je nad canvasem                        if (y0 + deltaY) > (self.canvasHeight - (self.nodeSize / 2) - 1): # obdelnik je pod canvasem                            y = randrange((self.nodeSize / 2) + 1, self.canvasHeight - (self.nodeSize / 2)) # Nahore i dole                        else:                            y = randrange((self.nodeSize / 2) + 1, y0 + deltaY) # obdelnik je jen nad canvasem                    else:                        if (y0 + deltaY) > (self.canvasHeight - (self.nodeSize / 2) - 1): # obdelnik je pod canvasem                            y = randrange(y0 - deltaY + 1, self.canvasHeight - (self.nodeSize / 2)) # Jen dole                        else: # ani nad ani pod                            y = randrange(y0 - deltaY + 1, y0 + deltaY) # Ani nad ani pod                    x -= self.nodeSize / 2                    y -= self.nodeSize / 2                    if not self.nodeList.count((x,y)):                        self.nodeList.append((x, y))                        for i in range(0, len(self.nodeList) - 1):                            x1, y1 = self.nodeList[i]        #                   Choosing nodes which can hear eachother                            if hypot(x1 - x, y1 - y) < self.screen.radius:                                neighboursList = [(x, y)]                                neighboursList.append((x1, y1))                                self.finalNodeList.append(neighboursList)#            Grid generation            if self.topologyGenMethod == 4 and not self.screen.islinkLayerGeneration:                self.nodeList = []                self.numberOfXNodes = int(self.gridXEntry.get_text())                self.numberOfYNodes = int(self.gridYEntry.get_text())                self.xSpace = (self.canvasWidth - (self.numberOfXNodes*self.nodeSize + 2)) / (self.numberOfXNodes + 1)                self.ySpace = (self.canvasHeight - (self.numberOfYNodes*self.nodeSize + 2)) / (self.numberOfYNodes + 1)                if self.numberOfXNodes == 1:                    self.minRadius = self.ySpace + self.nodeSize + 3                    if self.radius < self.minRadius:                        self.radiusEntry.set_text(str(self.minRadius))                        self.screen.setParameters(self.minRadius)                elif self.numberOfYNodes == 1:                    self.minRadius = self.xSpace + self.nodeSize + 3                    if self.radius < self.minRadius:                        self.radiusEntry.set_text(str(self.minRadius))                        self.screen.setParameters(self.minRadius)                elif self.radius < max(self.xSpace + self.nodeSize + 3, self.ySpace + self.nodeSize + 3):                    self.radiusEntry.set_text(str(max(self.xSpace + self.nodeSize + 3, self.ySpace + self.nodeSize + 3)))                    self.screen.setParameters(max(self.xSpace + self.nodeSize + 3, self.ySpace + self.nodeSize + 3))                x = 0                for i in range(0, self.numberOfXNodes):                    if i == 0:                        x = x + self.xSpace                    else:                        x = x + self.xSpace + self.nodeSize + 2                    y = 0                    for j in range(0, self.numberOfYNodes):                        if j == 0:                            y = y + self.ySpace                        else:                            y = y + self.ySpace + self.nodeSize + 2                        self.nodeList.append((x, y))#                        Choosing nodes which can hear eachother                        for k in range(0, len(self.nodeList)):                            x1, y1 = self.nodeList[k]                            if hypot(x1 - x, y1 - y) < self.screen.radius:                                neighboursSet = [(x, y)]                                neighboursSet.append((x1, y1))                                self.finalNodeList.append(neighboursSet)            if self.screen.islinkLayerGeneration:                linkLayerGenerateTopology = open("topology.out", "r")                topology = linkLayerGenerateTopology.read()                row = topology.split("\n")                for i in row:                    fields = i.split("\t")                    if len(fields) == 3:                        x = int(round(float(fields[1]) * 10,0))                         y = int(round(float(fields[2]) * 10,0))                        f = (x,y)                        self.finalNodeList.append(f)                    linkLayerGenerateTopology.close()                     #                self.screen.setList(self.finalNodeList)                                                     if generation:                                        self.screen.setList(self.finalNodeList)            else:                self.screen.currentDrawMethod = self.screen.drawError                self.screen.window.invalidate_rect((0,0,self.screen.area.width,self.screen.area.height),False)                                                          self.screen.getAllNodesList()            self.screen.linkLayerModel()                    #self.playTossim(widget, data)                      except ValueError, e:            print e            md = gtk.MessageDialog(self.window,            gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR,            gtk.BUTTONS_CLOSE, "Error")            md.run()            md.destroy()#    This method sets if the radio should be shown and redraw the canvas.    def setShowRadius(self, checkbutton, data):        self.screen.showRadius = checkbutton.get_active()        self.screen.currentDrawMethod = self.screen.drawAll        self.screen.window.invalidate_rect((0,0,self.screen.area.width,self.screen.area.height),False)#    This method writes the size of the canvas with each resizing. It also#    resize window after setting proportions in Entrys.    def showSize(self, widget, event):        try:            if self.screen.baseSurface != None:                self.canvasXEntry.set_text(str(self.window.get_size()[0] - self.screen.area.x))                self.canvasYEntry.set_text(str(self.window.get_size()[1] - self.screen.area.y))                self.screen.currentDrawMethod = self.screen.drawAll#                Vykresluje jen cast okna...nee uplne cely pri zvetseni                self.screen.window.invalidate_rect((0,0,self.screen.area.width,self.screen.area.height),False)                self.screen.window.process_updates(False)                if self.screen.boxVisible == True:                    self.screen.update(self.screen.drawInfoBox)        except Exception, e:            print e    def setLinkLayerModel(self, checkbutton, data):        self.screen.islinkLayerGeneration = checkbutton.get_active()        self.randomRadioButton.set_active(0)                if self.screen.islinkLayerGeneration:            self.maxRadioButton.hide()            self.coherentRadioButton.hide()            self.uniformRadioButton.show()            self.numberEntry.set_sensitive(True)                    else:                            self.maxRadioButton.show()                        self.coherentRadioButton.show()            self.uniformRadioButton.hide()            #    This method shows or hides neighboursLimitLabel, neighboursLimitEntry, gridLabel,#    gridXLabel, gridYLabel, gridXEntry, gridYEntry and (un)sets numberEntry sensitive.    def setMethod(self, widget, data):                #hide all        self.neighboursLimitLabel.hide()        self.neighboursLimitEntry.hide()        self.gridLabel.hide()        self.gridXLabel.hide()        self.gridYLabel.hide()        self.gridXEntry.hide()        self.gridYEntry.hide()        self.gridYEntry.hide()        self.gridUnitEntry.hide()        self.gridUnitLabel.hide()        self.radiusEntry.hide()                self.radiusLabel.hide()        self.numberEntry.set_sensitive(True)                if self.screen.islinkLayerGeneration and (data == 4 or data == 15):            self.gridUnitEntry.show()            self.gridUnitLabel.show()                         elif data == 2:            self.neighboursLimitLabel.show()            self.neighboursLimitEntry.show()            self.radiusEntry.show()                    self.radiusLabel.show()                    elif data == 4:            self.gridLabel.show()            self.gridXLabel.show()            self.gridYLabel.show()            self.gridXEntry.show()            self.gridYEntry.show()            self.neighboursLimitLabel.hide()            self.neighboursLimitEntry.hide()            self.numberEntry.set_sensitive(False)        else:                        self.radiusEntry.hide()                    self.radiusLabel.hide()        self.topologyGenMethod = data                #    This method opens topology file.        def openTopology(self, widget, data):        import os        dialog = gtk.FileChooserDialog("Open topology", None, gtk.FILE_CHOOSER_ACTION_OPEN, (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_OPEN, gtk.RESPONSE_OK))        dialog.set_default_response(gtk.RESPONSE_OK)        dialog.set_current_folder(os.getcwd())        filter = gtk.FileFilter()        filter.set_name("TXT")        filter.add_pattern("*.txt")        dialog.add_filter(filter)        filter = gtk.FileFilter()        filter.set_name("All files")        filter.add_pattern("*")        dialog.add_filter(filter)        response = dialog.run()        if response == gtk.RESPONSE_OK:            self.screen.readTopology(dialog.get_filename())            self.nodeList = self.screen.nodeList            self.numberOfNodes = self.screen.numberOfMotes            self.radius = self.screen.radius            self.numberEntry.set_text(str(self.numberOfNodes))            self.radiusEntry.set_text(str(self.radius))#            Erasing data from the previous animation            self.screen.com = False            self.screen.nodesMemory = {}            print self.nodeList    #       Extracting all nodes            self.allNodesList = []            for nodeTuple in self.nodeList:                node0 = nodeTuple[0]                node1 = nodeTuple[1]                if not self.allNodesList.count(node0):                    self.allNodesList.append(node0)                if not self.allNodesList.count(node1):                    self.allNodesList.append(node1)            self.numberOfMotes = len(self.allNodesList)                                                        dialog.destroy()        self.screen.linkLayerModel()        self.playTossim(widget, data)#    This method opens log file.    def openTossimLog(self, widget, data):        import os        if self.screen.logOpend:            self.screen.tossimLogFile.close()        dialog = gtk.FileChooserDialog("Open log", None, gtk.FILE_CHOOSER_ACTION_OPEN, (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_OPEN, gtk.RESPONSE_OK))        dialog.set_default_response(gtk.RESPONSE_OK)        dialog.set_current_folder(os.getcwd())        filter = gtk.FileFilter()        filter.set_name("LOG")        filter.add_pattern("*.log")        dialog.add_filter(filter)        filter = gtk.FileFilter()        filter.set_name("All files")        filter.add_pattern("*")        dialog.add_filter(filter)        response = dialog.run()        if response == gtk.RESPONSE_OK:            self.tossimLogFilename = dialog.get_filename()            self.playButton.set_sensitive(True)            self.stepButton.set_sensitive(True)            self.pauseButton.set_sensitive(True)            self.screen.setLogPath(self.tossimLogFilename)#            Erasing data from the previous animation            self.screen.com = False            self.screen.nodesMemory = {}            self.screen.update(self.screen.drawAll)        dialog.destroy()                    class Screen(gtk.DrawingArea):    def __init__(self):        super(Screen, self).__init__()        self.connect("expose_event", self.expose)        self.pangolayout = self.create_pango_layout("")        self.add_events(gtk.gdk.BUTTON_PRESS_MASK)        self.speed = 50        """        self.add_events(gtk.gdk.POINTER_MOTION_MASK |                        gtk.gdk.POINTER_MOTION_HINT_MASK |                        gtk.gdk.BUTTON_RELEASE_MASK |                        gtk.gdk.BUTTON_PRESS_MASK)        self.connect("button_press_event", self.showNodeInfo)        self.connect("button_release_event", self.release)        self.connect("motion_notify_event", self.showNodeInfo)        """        self.allConnections = [] #[0,10][-55(gain)][1(radiusQuality)],...        self.allNodesList = [] #index(nodeID) = (625,397),(492,297)... getAllNodesList transform values from nodList        self.nodeList = [] # ([627,647],[627,647]), ([627,647],[356,415])        self.showRadius = False        self.nodeSize = 10        self.currentDrawMethod = self.drawAll        self.comTuple = []        self.visitedTuple = []        self.baseSurface = None        self.infoSurface = None#        self.infoSurface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 0, 0)        self.row = []        self.nodeX = -1        self.nodeY = -1        self.nodeWithBox = (-1, -1)        self.possition = 0        self.boxVisible = False        self.tossimLogFile = None        self.logOpend = False        self.com = False        self.nodesMemory = {}                 self.attackerNodesList = [[97,0,"John",0],[11,0,"Jack",0],[92,0,"Ted",0]] # NODEID:[nodeID,cykle,name,numberofhops]             self.numberOfAttackers = 3 # NODEID:[cykle,name,numberofhops]        self.attackerNodesList = [] # NODEID:[nodeID,cykle,name,numberofhops]             self.attackerNodesList = [[3,0,"John",0],[0,0,"Jack",0],[11,0,"Ted",0]] # NODEID:[nodeID,cykle,name,numberofhops]        self.numberOfAttackers = 0 # NODEID:[cykle,name,numberofhops]                self.numberOfCykles = 0        self.appName = None          self.pandaNode = 1        self.isSecurityTest = False        self.communicationIsOn = False        self.visualisationIsOn = True                 self.islinkLayerGeneration = False; # True if generating by LLM        self.islinkLayerTopology = False; # True if loading LLM topology     def variablesShow(self, node):        variables = []        m = t.getNode(node)        print node        for i in self.variableList:                appName = self.variableAllList[i]                 v = m.getVariable(appName+"." + i)                           append = i + ": " + str(v.getData());        #   print append      #            if len(append) < 80:            variables.append(append)        return variables                    def expose(self, widget, event):#        print "expose"        cr = widget.window.cairo_create()#        set a clip region for the expose event        cr.rectangle(event.area.x, event.area.y,                     event.area.width, event.area.height)        cr.clip()        self.mainDraw(cr)        return False    """    def myInvalidate(self):        self.window.invalidate_rect((0,0,self.area.width,self.area.height),False)        return False    """    def mainDraw(self, cr):        self.area = self.get_allocation()#        print "Cairo (", self.area.x, self.area.y, self.area.width, self.area.height, ")"        self.currentDrawMethod(cr)#    This is the default drawing method which draws all layers and save them into baseSurface.    def drawAll(self, cr):        #        print "DrawAll"        self.baseSurface = cairo.ImageSurface(cairo.FORMAT_ARGB32, self.area.width, self.area.height)                crBase = cairo.Context(self.baseSurface)        crBase.set_source_rgb(1.0, 1.0, 1.0)  #rgb / 255        crBase.rectangle(0, 0, self.area.width, self.area.height)        crBase.fill()#        Extracting all nodes        """self.allNodesList = []        for nodeTuple in self.nodeList:            node0 = nodeTuple[0]            node1 = nodeTuple[1]            if not self.allNodesList.count(node0):                self.allNodesList.append(node0)            if not self.allNodesList.count(node1):                self.allNodesList.append(node1)        self.numberOfMotes = len(self.allNodesList)"""#        Drawing communication areas        if self.showRadius:            for node in self.allNodesList:                x, y = node                crBase.set_source_rgba(0.24, 0.21, 1.0, 0.2)                crBase.set_line_width(1.0)                crBase.arc(x+5, y+5, self.radius, 0, 2 * pi)                crBase.stroke()            self.showRadius = True#        Connecting nodes        crBase.set_line_width(2.0)        for connection in self.allConnections:                      if connection[2] < 3:                                   x0, y0 = self.allNodesList[int(connection[0][0])]                x1, y1 = self.allNodesList[connection[0][1]]                crBase.set_source_rgba(0.0, 0.0, 0.0, 0.5)                if connection[2] == 2:                    crBase.set_source_rgba(0.0, 0.0, 0.0, 0.1)                crBase.move_to(x0+(self.nodeSize / 2), y0+(self.nodeSize / 2))                crBase.line_to(x1+(self.nodeSize / 2), y1+(self.nodeSize / 2))                crBase.stroke()                        """for nodeTuple in self.nodeList:                            node0 = nodeTuple[0]            node1 = nodeTuple[1]            x0, y0 = node1            x1, y1 = node0                        print str(self.allNodesList.index(nodeTuple[0])) + " ->" + str(self.allNodesList.index(nodeTuple[1]))#            print str(self.allNodesList[nodeTuple])            if self.showRadius:                crBase.set_source_rgba(0.0, 0.0, 0.0, 0.5)            else:                crBase.set_source_rgba(0.0, 0.0, 0.0, 0.2)            crBase.move_to(x0+(self.nodeSize / 2), y0+(self.nodeSize / 2))            crBase.line_to(x1+(self.nodeSize / 2), y1+(self.nodeSize / 2))            crBase.stroke()"""                    #        Draving nodes        for node in self.allNodesList:                        x, y = node            if x > self.area.width or y > self.area.height:                continue                        crBase.set_source_rgb(0, 0, 0)            crBase.rectangle(x - 1, y - 1, self.nodeSize + 2, self.nodeSize + 2)            crBase.fill()            # draw root node            if node == self.nodeList[0][0]:                                crBase.set_source_rgb(0, 0, 0)                  crBase.rectangle(x, y, self.nodeSize, self.nodeSize)                crBase.fill()                        # draw Panda white node            elif node == self.allNodesList[self.pandaNode]:                                crBase.set_source_rgb(100, 100, 100)                crBase.rectangle(x, y, self.nodeSize, self.nodeSize)                crBase.fill()            else:                crBase.set_source_rgb(0, 0.8, 0)                crBase.rectangle(x, y, self.nodeSize, self.nodeSize)                crBase.fill()            # draw attacker red node                        for i in range(0,self.numberOfAttackers):                                if self.allNodesList.index(node) == self.attackerNodesList[i][0]:                     if self.numberOfCykles <= 0:                             crBase.set_source_rgb(0.8, 0, 0)                    else:                        crBase.set_source_rgb(0, 0.8, 0)                           #                elif  self.allNodesList.index(node) in self.attackerNodesList:                      #                    crBase.set_source_rgb(0.8, 0, 0)                                 crBase.rectangle(x, y, self.nodeSize, self.nodeSize)                    crBase.fill()                                    cr.set_source_surface(self.baseSurface)        cr.paint()                     if len(self.comTuple) > 0:#            self.update(self.drawCommunicaton)            self.window.process_updates(False)#    Redraw the canvas to the base surface.    def redrawToBase(self, cr):        cr.set_source_surface(self.baseSurface)        cr.paint()        if self.boxVisible == True:            cr.set_source_surface(self.infoSurface)            cr.paint()        #    This method draws the communication itself.    def drawCommunicaton(self, cr):        self.comSurface = cairo.ImageSurface(cairo.FORMAT_ARGB32, self.area.width, self.area.height)        crCom = cairo.Context(self.comSurface)        if self.visualisationIsOn:            # visited Nodes            crCom.set_line_width(2.0)            for node in self.visitedTuple:                node0, node1 = node                x0, y0 = node0                x1, y1 = node1                        #if self.showRadius:                 #   crCom.set_source_rgb(0.0, 0.0, 0.0)                #else:                 #   crCom.set_source_rgb(0.0, 0.0, 1.0)                                if self.communicationIsOn:                    crCom.set_source_rgb(1.0, 0.0, 0.0)                    crCom.move_to(x0+(self.nodeSize / 2), y0+(self.nodeSize / 2))                    crCom.line_to(x1+(self.nodeSize / 2), y1+(self.nodeSize / 2))                    crCom.stroke()                        if self.communicationIsOn:                    crCom.set_source_rgb(1.0, 0.0, 0.0)                    #        Draving the aim of communication                    x = x0 + 5 - (x0 - x1) / 4                    y = y0 + 5 - (y0 - y1) / 4                    crCom.arc(x, y, 5, 0, 2 * pi)                    crCom.fill()                    x = x0 + 5 - (x0 - x1) / 2                    y = y0 + 5 - (y0 - y1) / 2                    crCom.arc(x, y, 7, 0, 2* pi)                    crCom.fill()                    x = x0 + 5 - 3*(x0 - x1) / 4                    y = y0 + 5 - 3*(y0 - y1) / 4                    crCom.arc(x, y, 10, 0, 2 * pi)                    crCom.fill()                  #        Connecting active nodes (Red nodes with circles)            crCom.set_line_width(2.0)            for node in self.comTuple:                node0, node1 = node                x0, y0 = node0                x1, y1 = node1                        if self.showRadius:                    crCom.set_source_rgb(1.0, 0.0, 0.0)                else:                    crCom.set_source_rgb(1.0, 0.0, 0.0) #blue                                    if not self.communicationIsOn:                                crCom.set_line_width(2.0)                    crCom.set_source_rgb(0.1, 0.5, 1) #green                    crCom.move_to(x0+(self.nodeSize / 2), y0+(self.nodeSize / 2))                    crCom.line_to(x1+(self.nodeSize / 2), y1+(self.nodeSize / 2))                    crCom.stroke()                        if self.communicationIsOn:                    #        Draving nodes                    crCom.set_source_rgb(0, 0, 0)                    crCom.rectangle(x0 - 1, y0 - 1, self.nodeSize + 2, self.nodeSize + 2)                    crCom.rectangle(x1 - 1, y1 - 1, self.nodeSize + 2, self.nodeSize + 2)                    crCom.set_source_rgb(0, 0, 0.8)                    crCom.rectangle(x0, y0, self.nodeSize, self.nodeSize)                    crCom.rectangle(x1, y1, self.nodeSize, self.nodeSize)                    crCom.fill()                                    # end of paiting                        cr.set_source_surface(self.baseSurface)                    cr.paint()                    cr.set_source_surface(self.comSurface)                    cr.paint()                            # Draving pand/attacker nodes            for node in self.allNodesList:                x, y = node                # draw attacker black node                for i in range(0,self.numberOfAttackers):                                   if self.allNodesList.index(node) == self.attackerNodesList[i][0]:                                                        crCom.set_source_rgb(0.8, 0, 0)                                              crCom.rectangle(x, y, self.nodeSize, self.nodeSize)                        crCom.fill()                # draw Panda white node                if node == self.allNodesList[self.pandaNode]:                                    crCom.set_source_rgb(100, 100, 100)                    crCom.rectangle(x, y, self.nodeSize, self.nodeSize)                    crCom.fill()                                                # end of paiting                cr.set_source_surface(self.baseSurface)            cr.paint()            cr.set_source_surface(self.comSurface)            cr.paint()            if self.boxVisible == True:                cr.set_source_surface(self.infoSurface)                            cr.paint()                            #    This method draws the information box about error during generation.    def drawError(self, cr):        generatingSurface = cairo.ImageSurface(cairo.FORMAT_ARGB32, self.area.width, self.area.height)        crGenerating = cairo.Context(generatingSurface)#        Rounded rectangle        crGenerating.set_source_rgb(0, 0.8, 0)        crGenerating.set_line_width(10)        crGenerating.arc(self.area.width/2 - 120, self.area.height/2 - 60, 10, 2 * (pi / 2), 3 * (pi / 2))        crGenerating.arc(self.area.width/2 + 120, self.area.height/2 - 60, 10, 3 * (pi / 2), 4 * (pi / 2))        crGenerating.arc(self.area.width/2 + 120, self.area.height/2 + 60, 10, 0 * (pi / 2), 1 * (pi / 2))  # ;o)        crGenerating.arc(self.area.width/2 - 120, self.area.height/2 + 60, 10, 1 * (pi / 2), 2 * (pi / 2))        crGenerating.close_path()        crGenerating.stroke_preserve()        crGenerating.set_source_rgb(1, 1, 1)        crGenerating.fill()        crGenerating.set_source_rgb(0, 0, 0)        crGenerating.select_font_face("Arial", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_BOLD)        crGenerating.set_font_size(17)        crGenerating.move_to(self.area.width/2 - 120, self.area.height/2 + 5)        crGenerating.show_text("Error: bad chosen parameters")        cr.set_source_surface(generatingSurface)        cr.paint()    def drawInfoBox2(self):        #base this on a message dialog        dialog = gtk.MessageDialog(            None,            gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,            gtk.MESSAGE_INFO,            gtk.BUTTONS_OK,            None)                dialog.set_markup('   Node id: ' + str(self.nodeBoxId)+ ", " + str(self.allNodesList[self.nodeBoxId]))        dialog.set_title('   Node id: ' + str(self.nodeBoxId))                                     vbox = gtk.VBox()                                #                Pango text        messagesSet = []        if self.nodeBoxId in self.nodesMemory:              messagesSet = self.nodesMemory[self.nodeBoxId] + "\n"                                                                 messagesSet = messagesSet + self.variablesShow(self.nodeBoxId)                       for i in messagesSet:                     label = gtk.Label(i)            label.set_alignment(0, 0)            vbox.pack_start(label, True, 5, 2)                                               dialog.vbox.pack_end(vbox, True, True, 0)                                dialog.show_all()                dialog.run()            dialog.destroy()        #        This method draws the information box with the nodes memory.    def drawInfoBox(self, cr):        self.infoSurface = cairo.ImageSurface(cairo.FORMAT_ARGB32, self.area.width, self.area.height)        crInfo = cairo.Context(self.infoSurface)        boxWidth = 250        boxHeight = 330        ###################################        #           pango layout          #        ###################################        pg = pangocairo.CairoContext(crInfo)        attr = pango.AttrList()        fg_color = pango.AttrForeground(1, 1, 1, 0, -1)        attr.insert(fg_color)        layout = pg.create_layout()        layout.set_width(pango.SCALE * (boxWidth - 4))        layout.set_spacing(pango.SCALE * 3)        layout.set_alignment(pango.ALIGN_LEFT)        layout.set_font_description(pango.FontDescription("Arial 9"))        layout.set_attributes(attr)#        layout.set_wrap(PANGO_WRAP_WORD_CHAR)#        layout.set_text("aaaaaaaaaaaaaaaaaaaaaaaaaaaaa aaaaa ")        ###################################        if (self.nodeX + self.nodeSize + 1 + boxWidth) > self.area.width: # overreach on the right side            if (self.nodeY - 1 - boxHeight) < 0: # overreach on the upper side#                Box with dark header    #overreach on the right and upper side                crInfo.set_source_rgba(0.8, 0.8, 0.8, 0.8)                crInfo.rectangle(self.nodeX - 1 - boxWidth, self.nodeY + self.nodeSize + 1, boxWidth, boxHeight)                crInfo.fill()                crInfo.set_source_rgba(0.5, 0.5, 0.5, 0.5)                crInfo.rectangle(self.nodeX - 1 - boxWidth, self.nodeY + self.nodeSize + 1, boxWidth, 16)                crInfo.fill()#                Pango text                messagesSet = []                if self.nodeBoxId in self.nodesMemory:                    messagesSet = self.nodesMemory[self.nodeBoxId]                                                messagesSet = messagesSet + self.variablesShow(self.nodeBoxId)                                move = 0                for i in range(len(messagesSet)-1, -1, -1):                    crInfo.move_to(self.nodeX - 1 - boxWidth + 2, self.nodeY + self.nodeSize + 1 + 14 + move)                    layout.set_text(messagesSet[i])                    move += 11                    pg.show_layout(layout)                #                else:#                    fg_color = pango.AttrForeground(55000, 0, 0, 0, -1)#                    attr.insert(fg_color)#                    layout.set_alignment(pango.ALIGN_CENTER)#                    layout.set_font_description(pango.FontDescription("Arial Bold 10"))#                    crInfo.move_to(self.nodeX - 1 - boxWidth + 2, self.nodeY + self.nodeSize + (boxHeight)/2 - 5)#                    layout.set_text("Empty")#                    pg.show_layout(layout)#                Headline                crInfo.set_source_rgb(1, 1, 1)                crInfo.select_font_face("Arial", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_BOLD)                crInfo.set_font_size(13)                crInfo.move_to(self.nodeX - 1 - boxWidth + 2, self.nodeY + self.nodeSize + 1 +13)                crInfo.show_text("Node %s" % (self.nodeBoxId))            else:#                Box with dark header    #overreach on the right side                crInfo.set_source_rgba(0.8, 0.8, 0.8, 0.8)                crInfo.rectangle(self.nodeX - 1 - boxWidth, self.nodeY - boxHeight - 1, boxWidth, boxHeight)                crInfo.fill()                crInfo.set_source_rgba(0.5, 0.5, 0.5, 0.5)                crInfo.rectangle(self.nodeX - 1 - boxWidth, self.nodeY - boxHeight - 1, boxWidth, 16)                crInfo.fill()#                Pango text                messagesSet = []                if self.nodeBoxId in self.nodesMemory:                    messagesSet = self.nodesMemory[self.nodeBoxId]                                                messagesSet = messagesSet + self.variablesShow(self.nodeBoxId)                                move = 0                                for i in range(len(messagesSet)-1, -1, -1):                    crInfo.move_to(self.nodeX - 1 - boxWidth + 2, self.nodeY - boxHeight + 14 + move)                    layout.set_text(messagesSet[i])                    move += 11                    pg.show_layout(layout)                                else:                    fg_color = pango.AttrForeground(55000, 0, 0, 0, -1)                    attr.insert(fg_color)                    layout.set_alignment(pango.ALIGN_CENTER)                    layout.set_font_description(pango.FontDescription("Arial Bold 10"))                    crInfo.move_to(self.nodeX - 1 - boxWidth + 2, self.nodeY - (boxHeight)/2 -5)                    layout.set_text("Empty")                    pg.show_layout(layout)#                Headline                crInfo.set_source_rgb(1, 1, 1)                crInfo.select_font_face("Arial", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_BOLD)                crInfo.set_font_size(13)                crInfo.move_to(self.nodeX - 1 - boxWidth + 2, self.nodeY+13-boxHeight)                crInfo.show_text("Node %s" % (self.nodeBoxId))        else:            if (self.nodeY - 1 - boxHeight) < 0: # overreach on the upper side#                Box with dark header                crInfo.set_source_rgba(0.8, 0.8, 0.8, 0.8)                crInfo.rectangle(self.nodeX + 11, self.nodeY + self.nodeSize + 1, boxWidth, boxHeight)                crInfo.fill()                crInfo.set_source_rgba(0.5, 0.5, 0.5, 0.5)                crInfo.rectangle(self.nodeX + 11, self.nodeY + self.nodeSize + 1, boxWidth, 16)                crInfo.fill()#                Pango text                messagesSet = []                if self.nodeBoxId in self.nodesMemory:                    messagesSet = self.nodesMemory[self.nodeBoxId]                                                messagesSet = messagesSet + self.variablesShow(self.nodeBoxId)                move = 0                     for i in range(len(messagesSet)-1, -1, -1):                    crInfo.move_to(self.nodeX + 13, self.nodeY + self.nodeSize + 1 + 14 + move)                    layout.set_text(messagesSet[i])                    move += 11                    pg.show_layout(layout)                else:                    fg_color = pango.AttrForeground(55000, 0, 0, 0, -1)                    attr.insert(fg_color)                    layout.set_alignment(pango.ALIGN_CENTER)                    layout.set_font_description(pango.FontDescription("Arial Bold 10"))                    crInfo.move_to(self.nodeX + 13, self.nodeY + (boxHeight)/2 + 5 + 1)                    layout.set_text("Empty")                    pg.show_layout(layout)#                Headline                crInfo.set_source_rgb(1, 1, 1)                crInfo.select_font_face("Arial", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_BOLD)                crInfo.set_font_size(13)                crInfo.move_to(self.nodeX + 13, self.nodeY + self.nodeSize + 1 +13)                crInfo.show_text("Node %s" % (self.nodeBoxId))            else:#dont overreach on any side#                Box with dark header                crInfo.set_source_rgba(0.8, 0.8, 0.8, 0.8)                crInfo.rectangle(self.nodeX + 11, self.nodeY - boxHeight - 1, boxWidth, boxHeight)                crInfo.fill()                crInfo.set_source_rgba(0.5, 0.5, 0.5, 0.5)                crInfo.rectangle(self.nodeX + 11, self.nodeY - boxHeight - 1, boxWidth, 16)                crInfo.fill()#                Pango text                messagesSet = []                if self.nodeBoxId in self.nodesMemory:                    messagesSet = self.nodesMemory[self.nodeBoxId]                                                messagesSet = messagesSet + self.variablesShow(self.nodeBoxId)                move = 0                     for i in range(len(messagesSet)-1, -1, -1):                    crInfo.move_to(self.nodeX + 13, self.nodeY - boxHeight + 14 + move)                    layout.set_text(messagesSet[i])                    move += 11                    pg.show_layout(layout)                else:                    fg_color = pango.AttrForeground(55000, 0, 0, 0, -1)                    attr.insert(fg_color)                    layout.set_alignment(pango.ALIGN_CENTER)                    layout.set_font_description(pango.FontDescription("Arial Bold 10"))                    crInfo.move_to(self.nodeX + 13, self.nodeY - (boxHeight)/2 -5)                    layout.set_text("Empty")                    pg.show_layout(layout)#                Headline                crInfo.set_source_rgb(1, 1, 1)                crInfo.select_font_face("Arial", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_BOLD)                crInfo.set_font_size(13)                crInfo.move_to(self.nodeX + 13, self.nodeY + 13 - boxHeight)                crInfo.show_text("Node %s" % (self.nodeBoxId))        cr.set_source_surface(self.baseSurface)        cr.paint()        if self.com == True:            cr.set_source_surface(self.comSurface)            cr.paint()        cr.set_source_surface(self.infoSurface)        cr.paint()#    This method gets the node specifications and starts drawInfoBox method.    def showNodeInfo(self, widget, event):        mouseX, mouseY = self.get_pointer()        self.nodeX = -1        self.nodeY = -1        for node in self.allNodesList:            nodeX, nodeY = node            if ((nodeX - 1) <= mouseX) and (mouseX <= (nodeX + self.nodeSize + 1)):                if ((nodeY - 1) <= mouseY) and (mouseY <= (nodeY + self.nodeSize + 1)):                    self.nodeX = nodeX                    self.nodeY = nodeY                    self.nodeBoxId = self.allNodesList.index(node)        if self.nodeWithBox != (self.nodeX, self.nodeY) and (self.nodeX, self.nodeY) != (-1, -1):                        self.drawInfoBox2()#            self.nodeWithBox = (self.nodeX, self.nodeY)#            self.update(self.drawInfoBox)#            self.boxVisible = True        else:            self.nodeWithBox = (-1, -1)            self.boxVisible = False            if self.com == True:                self.update(self.drawCommunicaton)            else:                self.update(self.drawAll)                    def endOfSecurityTest(self, attackerId):        #base this on a message dialog        dialog = gtk.MessageDialog(            None,            gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,            gtk.MESSAGE_INFO,            gtk.BUTTONS_OK,            None)        dialog.set_markup('    Results of security test:    ')        #        print str(self.attackerNodesList[attackerId])            hbox = gtk.HBox()                output = "Hunter '" + str(self.attackerNodesList[attackerId][2]) + "' reached panda after:\n\n" + str(self.numberOfCykles) + " cykles \nby " + str(self.attackerNodesList[attackerId][3]) +" hops"                if len(self.attackerNodesList) > 1:                        output += "\n\n"            for i in range(0, self.numberOfAttackers):                print str(i)                output += "\nHunter '" + str(self.attackerNodesList[i][2]) + "'\nmade " + str(self.attackerNodesList[i][3]) +" hops"                hbox.pack_start(gtk.Label(output), False, 5, 5)        dialog.vbox.pack_end(hbox, True, True, 0)        #" + str(self.attackerNodesList[nodeId][2]))        #self.listStore = gtk.ListStore(gobject.TYPE_STRING)        #self.cbRemove = gtk.combo_box_new_text()        #self.cbAdd = gtk.combo_box_new_text()        #cb.connect("changed", self.combo_changed)        #self.cbRemove.append_text("Displayed variables")        #for i in self.screen.variableList:                        #self.cbRemove.append_text(i)                    #self.cbAdd.append_text("All variables")        #for i in self.screen.variableAllList:         #   if not i in self.screen.variableList:          #      self.cbAdd.append_text(i)                    #self.cbRemove.set_active(0)        #self.cbAdd.set_active(0)                       #create the text input field        entry = gtk.Entry()        #allow the user to press enter to do ok        #entry.connect("activate", responseToDialog, dialog, gtk.RESPONSE_OK)        #create a horizontal box to pack the entry and a label        hbox = gtk.HBox()        #hbox.pack_start(gtk.Label("Add variable:"), False, 5, 5)        #hbox.pack_start(self.cbAdd, False, 5, 5)        addVariableButton =  gtk.Button("Add variable")        #hbox.pack_start(addVariableButton, False, 5, 5)        dialog.vbox.pack_end(hbox, True, True, 0)                hbox = gtk.HBox()                #hbox.pack_start(gtk.Label(":"), False, 5, 5)                #hbox.pack_start(self.cbRemove, True, 5, 5)        removeVariableButton =  gtk.Button("Remove variable")        #hbox.pack_start(removeVariableButton, False, 5, 5)        dialog.vbox.pack_end(hbox, True, True, 0)                        #removeVariableButton.connect("clicked", self.removeVariable, None)        #addVariableButton.connect("clicked", self.addVariable, None)                dialog.show_all()        addVariableButton.show()        #self.cbAdd.show()        #self.cbRemove.show()                dialog.run()        text = entry.get_text()        dialog.destroy()        return text    #    This method gets nodeList from the Window class.    def setList(self, list):        self.nodeList = list        self.update(self.drawAll)#    This method redraw canvas.    def update(self, method):        self.currentDrawMethod = method        self.window.invalidate_rect((0,0,self.area.width,self.area.height),False)#    This method gets radius from the Window class.    def setParameters(self, radius):        self.radius = radius        #    This method generates topology files.    def writeTopology(self, widget, data):#        Inicialization of the topologyPy string with header for TOSSIM script        topologyPy = "#! /usr/bin/python\nfrom TOSSIM import *\n\nt = Tossim([])\nr = t.radio()\n"#        Inicialization of the topologyTxt string        topologyTxt = "%s\n" % self.radius#        Insert nodes inicializations        for node in range(self.numberOfMotes):            topologyPy += "\nmote%s = t.getNode(%s)" % (node, node)                            print str(self.nodeList)#        Generating topology sources        for nodeTuple in self.nodeList:            node0 = nodeTuple[0]            node1 = nodeTuple[1]            if self.islinkLayerGeneration:                x0  = node0                 y0  = node1                x1 =  node0                y1  = node1            else:                x0, y0 = node0                x1, y1 = node1                        topologyTxt += "%s %s %s %s\n" % (x0, y0, x1, y1)            if node1 != node0 and False:                gain = hypot(x1 - x0, y1 - y0) * 100 / self.radius                topologyPy += "\nr.add(%s, %s, -%s)" % (self.allNodesList.index((x0, y0)), self.allNodesList.index((x1, y1)), round(gain))                topologyPy += "\nr.add(%s, %s, -%s)" % (self.allNodesList.index((x0, y0)), self.allNodesList.index((x1, y1)), round(gain))        dialog = gtk.FileChooserDialog("Save",            None, gtk.FILE_CHOOSER_ACTION_SAVE,            (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_SAVE, gtk.RESPONSE_OK))        dialog.set_default_response(gtk.RESPONSE_OK)        dialog.set_current_name("viz")        response = dialog.run()        if response == gtk.RESPONSE_OK:    #        Writing to the file(script.py)            f = open("%s.py" % (dialog.get_filename()), "w")            f.write(topologyPy)            f.close()    #        Writing to file(topology.txt)            f = open("%s.txt" % (dialog.get_filename()), "w")            f.write(topologyTxt)            f.close()        dialog.destroy()      # Generate LinkLayer topology file              def linkLayerModel(self):                                                           i = 0        # write temp topo file        f = open("Simviz/LinkLayerTopo", "w")        if len(self.allNodesList) < 60:                                                   for node in self.allNodesList:                                f.write(str(i)+ " " + str(float(node[0]) / 10) + " " + str(float(node[1]) / 10) + "\n")                i += 1        else:            for node in self.allNodesList:                                f.write(str(i)+ " " + str(float(node[0]) / 5) + " " + str(float(node[1]) / 5) + "\n")                i += 1                                f.close()                         # run java LinkLayerModel        os.system("java -classpath /opt/tinyos-2.1.0/support/sdk/java/tinyos.jar net.tinyos.sim.LinkLayerModel "+os.getcwd()+"/Simviz/LinkLayerConfig")        self.generateRadius()        #This method reads topology file.    def generateRadius(self):    #    def readTopology(self, widget, filePath):                self.allConnections = []#        self.nodeList = []        #        numberOfNodesSet = set()        f = open("linkgain.out","r")        linkgaion = f.read()        row = linkgaion.split("\n")        for i in row:            fields = i.split("\t")            if fields[0] == "gain":                       radiusQuality = 3 # can`t hear each other                                                           if float(fields[3]) > -48:                    radiusQuality = 2                                 if float(fields[3]) > -38:                    radiusQuality = 1                                    if float(fields[3]) < -48:                    fields[3] = -98                                    self.allConnections.append([[int(fields[1]), int(fields[2])], float(fields[3]), radiusQuality])                #print [[fields[1], fields[2]], fields[3]]                                   f.close()        self.update(self.drawAll)#    This method reads topology file.    def readLinkLayerTopology(self, filePath):        simVizConfig = open(filePath, "r")        try:            file = simVizConfig.read()            row = file.split("\n")            for i in row:                                fields = i.split("\t")                                                        # Read debug channels from config                  if fields[0] >= 0:                    self.allNodesList.append(( int(float(fields[1])), int(float(fields[2])) ))                     self.nodeList.append(( int(float(fields[1])), int(float(fields[2])) ))                                               except Exception, e:            print "Not linkLayerTopology file: '"+filePath+"'";            print e;                        self.numberOfMotes = len(self.allNodesList)                   simVizConfig.close()        print "Loaded"        print "" + str(self.allNodesList)                            self.update(self.drawAll)            def readTopology(self, filePath):#    def readTopology(self, widget, filePath):        self.nodeList = []        file = open(filePath, "rb")        reader = csv.reader(file, delimiter=' ', quoting=csv.QUOTE_NONE)        numberOfNodesSet = set()        try:            for row in reader:                if len(row) == 1:                    self.radius = int(row[0])                else:                    x0 = int(row[0])                    y0 = int(row[1])                    x1 = int(row[2])                    y1 = int(row[3])                    nodeTuple = [(x0, y0)]                    nodeTuple.append((x1, y1))                    numberOfNodesSet.add((x0, y0))                    numberOfNodesSet.add((x1, y1))                    self.nodeList.append(nodeTuple)                                self.numberOfMotes = len(numberOfNodesSet)                        self.getAllNodesList()                        #                Extracting all nodes                                    #            return self.nodeList                                except ValueError:#            md = gtk.MessageDialog(self.window,#            gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR,#            gtk.BUTTONS_CLOSE, "Bad topology file.")#            md.run()#            md.destroy()            print "Bad topology file."                        file.close()                    file.close()        self.update(self.drawAll)        # transform nodList to allNodeList    def getAllNodesList(self):                      self.allNodesList = [] # index(nodeID) = (625,397),(492,297)...#        print str(self.nodeList)        # If generated by LinkLayerModel        if self.islinkLayerGeneration:            self.allNodesList = self.nodeList            self.numberOfMotes = len(self.allNodesList)        # Simviz generation                    else:                for nodeTuple in self.nodeList:                node0 = nodeTuple[0]                node1 = nodeTuple[1]                if not self.allNodesList.count(node0):                    self.allNodesList.append(node0)                    if not self.allNodesList.count(node1):                        self.allNodesList.append(node1)                    self.numberOfMotes = len(self.allNodesList)#        print str(self.numberOfMotes);        #    This method saves path of the log file into tossimLogFilename variable.    def setLogPath(self, path):        self.tossimLogFilename = path#    This method steps the log file.    def stepTossimLog(self, widget, data):        if not self.logOpend:            self.tossimLogFile = open(self.tossimLogFilename, "r")            self.nodesMemory = {}            self.logOpend = True        self.pauseTimer = False        self.tossimLogFile.seek(self.possition)        self.drawingTimer(self.tossimLogFile)#    This method controls the pause of the simulation.    def pauseTossimLog(self, widget, data):        self.possition = self.tossimLogFile.tell()        self.pauseTimer = True        self.drawingTimer(self.tossimLogFile)#    This method starts the timer for the simulation.    def playTossimLog(self, widget, data):        if not self.logOpend:            self.tossimLogFile = open(self.tossimLogFilename, "r")            self.nodesMemory = {}            self.logOpend = True        self.tossimLogFile.seek(self.possition)        self.pauseTimer = False        self.timer = gobject.timeout_add(self.speed, self.drawingTimer, self.tossimLogFile)        #    This method controls (re)drawing of the simulation.    def drawingTimer(self, tossimLogFile, nodeList):                self.comTuple = []        tossimLogFile.seek(self.possition)                        while True:            self.com = True            line = tossimLogFile.readline()                                        if line == "":                   if len(self.comTuple) > 0:                    self.update(self.drawCommunicaton)                    self.window.process_updates(False)                                                                  self.logOpend = True                self.com = False                                                return False            else:                                self.possition = tossimLogFile.tell()                                lineList = [line]                reader = csv.reader(lineList, delimiter=' ', quoting=csv.QUOTE_NONE)                row = reader.next()                                            if len(row) > 0:                if row[0] == "DEBUG":                    nodeId = int(row[1].strip("():"))    #            Sending paket:                    if row[2] == "received":                        if row[3] == "from":                            if len(row) > 4:                                self.allNodesList.append(self.allNodesList[6])                                print "Display "+ str(int(row[4])) + " => "+str(nodeId)                                nodeTo = self.allNodesList[nodeId]#                               print "Node from "+str(nodeId) + " = " + str(nodeTo)                                nodeFrom = self.allNodesList[int(row[4])]                                                                        #                               nodeTo = nodeList[nodeId]#                                    print nodeTo#                                    nodeFrom = nodeList[int(row[4])]                                                                    self.comTuple.append([nodeFrom, nodeTo])                                                                    self.visitedTuple.append([nodeFrom, nodeTo])                                                                             # MOVE ATTACKER                                if self.isSecurityTest:                                         for i in range(0,self.numberOfAttackers):                                                               if (nodeId == self.attackerNodesList[i][0]) and (nodeId != self.pandaNode):                                                  # check number of cykles                                            if self.attackerNodesList[i][1] < self.numberOfCykles:                                                                                                                                                                                                                           a = self.attackerNodesList[i]                                                self.attackerNodesList[i] = [int(row[4]),self.numberOfCykles,a[2],a[3] + 1]                                                                                                  # END of SECURITY TEST                                                                                                                                        if int(row[4]) == self.pandaNode:                                                                                                        a = self.attackerNodesList[i]                                                    #print str(a) + " " + str(self.pandaNode) + " " + str(row[4])                                                    self.endOfSecurityTest(i)                                                    #print "Panda founded in: " + str(self.numberOfCykles) + " " + a[1] +" cykles" +str(int(row[4]))                                                                                                                    #            Content of the packet:                    if row[2] == "packet:":                        #print "packet"                        packetList = []                        for i in range(3, len(row)):                            packetList.append(row[i])                        packet = " ".join(packetList)                        #print "packet:", packet                        if nodeId in self.nodesMemory:                            memory = self.nodesMemory[nodeId]                            if len(memory) > 9:                                memory.popleft()                                memory.append(packet)                                self.nodesMemory[nodeId] = memory                            else:                                memory.append(packet)                                self.nodesMemory[nodeId] = memory                        else:                            memory = deque([packet])                            self.nodesMemory[nodeId] = memory                        if (self.boxVisible == True) and (self.nodeBoxId == nodeId):                            self.update(self.drawInfoBox)                            self.window.process_updates(False)                         def run():        window = Window()    window.main()if __name__ == "__main__":    run()